<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="index"><meta name="keywords" content=""><meta name="description" content="GPIO模式输入模式在此模式下，引脚用于读取外部信号的电平（高或低）。  浮空输入 描述：引脚内部既不上拉到高电平，也不下拉到低电平，完全由外部电路决定其电平状态。当外部没有连接或处于高阻态时，引脚电平是悬空、不确定的。 应用场景：用于连接外部有明确驱动能力的电路，如按键（需外接上拉或下拉电阻）、与其他IC通信且该IC有推挽输出等。不推荐用于悬空引脚，因为容易受噪声干扰。   上拉输入 描述：引脚"><meta property="og:type" content="article"><meta property="og:title" content="51"><meta property="og:url" content="https://indexqwq.github.io/2025/10/26/51/index.html"><meta property="og:site_name" content="indexQWQ"><meta property="og:description" content="GPIO模式输入模式在此模式下，引脚用于读取外部信号的电平（高或低）。  浮空输入 描述：引脚内部既不上拉到高电平，也不下拉到低电平，完全由外部电路决定其电平状态。当外部没有连接或处于高阻态时，引脚电平是悬空、不确定的。 应用场景：用于连接外部有明确驱动能力的电路，如按键（需外接上拉或下拉电阻）、与其他IC通信且该IC有推挽输出等。不推荐用于悬空引脚，因为容易受噪声干扰。   上拉输入 描述：引脚"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/ULN2003.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/SheetMusic.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Notation.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/NotesAndFrequencies.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Interruption_Structure.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Interrupt_Trigger.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Interrupt_Register.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/EEPROM.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_CircuitSpecifications.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_Condition.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_Send.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_Read.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_Answer.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_SendDataFrame.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_ReadDataFrame.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_SendReadDataFrame.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_ByteWrite.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/IIC_RandRead.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS18B20.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS18B20StructuralDiagram.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS18B20MemoryStructure.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_CircuitSpecifications.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_Init.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_SendBit.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_ReceiveBit.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS18B20_ConvertTemperture.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS18B20_ReadTemperature.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Temperature_MemoryStructure.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Temperature_MemoryStructure2.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/LCD1602.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_Structure.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_DDRAM.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_CGRAM_CGROM.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_TemporalStructure.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_InstructionSet.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Motor_DirectDrive.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Motor_H-BridgeDrive.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/PWM_Generate.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/ADDA_HardwareCircuitModel.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/ADDA_HardwardCircuit.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/OperationalAmplifier.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/OpAmpCircuit.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/OpAmpCircuit2.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DA_TConverter.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DA_TFormula.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DA_PWMConverter.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DA_PWMFormula.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/AD_SuccessivelyConverter.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/AD_SuccessivelyFormula.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/XTP2046.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/XPT2046Time.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/RedLED_HardwareCircuit.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/RedLED_SeedAndReceive.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/NEC_Code.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/Interrupt_Sign.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/RedLED_Key.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS1302_Introduction.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS1302_CommandWord.png"><meta property="og:image" content="https://live2d-api-jet.vercel.app/model/image/51/DS1302_RegisterAddress.png"><meta property="article:published_time" content="2025-10-26T11:29:23.000Z"><meta property="article:modified_time" content="2025-11-07T13:15:07.607Z"><meta property="article:author" content="index"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://live2d-api-jet.vercel.app/model/image/51/ULN2003.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>51 - indexQWQ</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"indexqwq.github.io",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 8.0.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Index</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="51"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-10-26 19:29" pubdate>2025年10月26日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 21k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 179 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">51</h1><div class="markdown-body"><h2 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a><strong>GPIO模式</strong></h2><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在此模式下，引脚用于读取外部信号的电平（高或低）。</p><ol><li><strong>浮空输入</strong><ul><li><strong>描述</strong>：引脚内部既不上拉到高电平，也不下拉到低电平，完全由外部电路决定其电平状态。当外部没有连接或处于高阻态时，引脚电平是悬空、不确定的。</li><li><strong>应用场景</strong>：用于连接外部有明确驱动能力的电路，如按键（需外接上拉或下拉电阻）、与其他IC通信且该IC有推挽输出等。<strong>不推荐用于悬空引脚</strong>，因为容易受噪声干扰。</li></ul></li><li><strong>上拉输入</strong><ul><li><strong>描述</strong>：引脚内部通过一个电阻连接到VCC（高电平）。当外部没有信号驱动时，引脚会被拉至高电平。</li><li><strong>应用场景</strong>：按键检测（按键另一端接地，按下时为低电平，松开时因上拉电阻变为高电平），用于确保默认状态为高。</li></ul></li><li><strong>下拉输入</strong><ul><li><strong>描述</strong>：引脚内部通过一个电阻连接到GND（低电平）。当外部没有信号驱动时，引脚会被拉至低电平。</li><li><strong>应用场景</strong>：按键检测（按键另一端接VCC，按下时为高电平，松开时因下拉电阻变为低电平），用于确保默认状态为低。</li></ul></li></ol><hr><h3 id="输出模式"><a href="#输出模式" class="headerlink" title="输出模式"></a>输出模式</h3><p>在此模式下，引脚用于驱动外部电路，输出高电平或低电平。</p><ol><li><strong>推挽输出</strong><ul><li><strong>描述</strong>：这是最常用的输出模式。它使用一对MOSFET（一个P-MOS，一个N-MOS），像“推”和“挽”一样工作。<ul><li>输出高电平时，P-MOS导通，直接连接到VCC，<strong>可以主动“推”出电流</strong>（源电流）。</li><li>输出低电平时，N-MOS导通，直接连接到GND，<strong>可以主动“拉入”电流</strong>（吸电流）。</li></ul></li><li><strong>特点</strong>：驱动能力强，高低电平都很稳定，不会出现高阻态。可以直接驱动LED、继电器等。</li><li><strong>应用场景</strong>：驱动大多数数字器件，如LED、蜂鸣器、通信总线（如SPI、I2C的主机SCK&#x2F;MOSI引脚）。</li></ul></li><li><strong>开漏输出</strong><ul><li><strong>描述</strong>：只有下拉的N-MOS，没有上拉的P-MOS。<ul><li>输出低电平时，N-MOS导通，将引脚拉至GND。</li><li>输出高电平时，N-MOS关闭，引脚处于<strong>高阻态</strong>（既不是高也不是低）。<strong>要得到高电平，必须外接一个上拉电阻到VCC</strong>。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>电平转换</strong>：方便实现不同电压域的设备通信。例如，3.3V的单片机可以通过开漏输出和上拉电阻到5V，与5V设备通信，而不会损坏单片机。</li><li><strong>线与功能</strong>：多个开漏输出的引脚可以直接连接在一起，实现“线与”逻辑。只要有一个输出低，总线就是低；所有都输出高，总线才是高。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>I2C通信总线</strong>（SDA, SCL）必须使用开漏模式，以实现多主机的“线与”仲裁。</li><li>需要电平转换的场合。</li><li>驱动高于单片机电压的器件（如通过外接上拉电阻到12V）。</li></ul></li></ul></li></ol><p>在输出模式下，通常还可以配置<strong>输出速度</strong>（低速、中速、高速、超高速），这决定了引脚电平切换的上升&#x2F;下降时间，影响EMI（电磁干扰）和功耗。</p><hr><h3 id="模拟模式"><a href="#模拟模式" class="headerlink" title="模拟模式"></a>模拟模式</h3><ol><li><strong>模拟输入&#x2F;输出</strong><ul><li><strong>描述</strong>：引脚完全与内部的数字电路断开连接，既不经过施密特触发器，也无法进行数字读写。引脚直接连接到片上的模拟外设。</li><li><strong>应用场景</strong>：<ul><li>作为<strong>ADC（模数转换器）</strong> 的输入，用于读取模拟传感器电压（如电位器、光敏电阻）。</li><li>作为<strong>DAC（数模转换器）</strong> 的输出，用于产生模拟电压。</li></ul></li><li><strong>重要提示</strong>：当引脚用作ADC或DAC时，<strong>必须</strong>配置为模拟模式，否则无法正确读取或产生模拟信号。</li></ul></li></ol><hr><h3 id="复用功能模式"><a href="#复用功能模式" class="headerlink" title="复用功能模式"></a>复用功能模式</h3><p>当引脚被用于单片机内部集成的特定外设时（如UART、SPI、I2C、TIM等），需要配置为此模式。</p><ol><li><strong>复用推挽输出</strong><ul><li><strong>描述</strong>：引脚作为片上外设（如SPI的SCK、MOSI）的输出端，其输出结构是推挽的。输出信号由外设硬件自动控制，而非程序直接写GPIO寄存器。</li><li><strong>应用场景</strong>：需要强驱动能力的通信外设输出，如SPI、SDIO、USART的TX引脚等。</li></ul></li><li><strong>复用开漏输出</strong><ul><li><strong>描述</strong>：引脚作为片上外设的输出端，但其输出结构是开漏的。</li><li><strong>应用场景</strong>：需要开漏特性的外设，如<strong>I2C</strong>的SDA和SCL引脚、USART的双向引脚等。</li></ul></li></ol><p><strong>注意</strong>：“复用功能”本身不区分输入输出，具体是输入还是输出由所连接的外设决定。例如，配置为USART_TX是复用输出，而配置为USART_RX则是复用输入。</p><hr><h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><table><thead><tr><th align="left">模式</th><th align="left">方向</th><th align="left">电平特性</th><th align="left">关键特点</th><th align="left">典型应用</th></tr></thead><tbody><tr><td align="left"><strong>浮空输入</strong></td><td align="left">输入</td><td align="left">高阻态</td><td align="left">电平不确定，易受干扰</td><td align="left">外部有强驱动的数字信号</td></tr><tr><td align="left"><strong>上拉输入</strong></td><td align="left">输入</td><td align="left">默认高电平</td><td align="left">内部上拉电阻</td><td align="left">按键（按键接地）</td></tr><tr><td align="left"><strong>下拉输入</strong></td><td align="left">输入</td><td align="left">默认低电平</td><td align="left">内部下拉电阻</td><td align="left">按键（按键接VCC）</td></tr><tr><td align="left"><strong>推挽输出</strong></td><td align="left">输出</td><td align="left">强高低电平</td><td align="left">驱动能力强，最常用</td><td align="left">驱动LED、数字器件、SPI等</td></tr><tr><td align="left"><strong>开漏输出</strong></td><td align="left">输出</td><td align="left">低&#x2F;高阻态</td><td align="left">需外接上拉，支持电平转换和“线与”</td><td align="left">I2C总线、电平转换</td></tr><tr><td align="left"><strong>模拟模式</strong></td><td align="left">输入&#x2F;输出</td><td align="left">直通</td><td align="left">断开数字电路</td><td align="left">ADC采样、DAC输出</td></tr><tr><td align="left"><strong>复用推挽</strong></td><td align="left">输出</td><td align="left">强高低电平</td><td align="left">信号由片上外设控制</td><td align="left">SPI_SCK, USART_TX</td></tr><tr><td align="left"><strong>复用开漏</strong></td><td align="left">输出</td><td align="left">低&#x2F;高阻态</td><td align="left">信号由片上外设控制，开漏特性</td><td align="left">I2C_SDA&#x2F;SCL</td></tr></tbody></table><p><strong>如何选择模式？</strong></p><ol><li><strong>读取开关&#x2F;按键状态</strong> -&gt; <strong>上拉输入</strong> 或 <strong>下拉输入</strong>。</li><li><strong>驱动LED</strong> -&gt; <strong>推挽输出</strong>。</li><li><strong>I2C通信</strong> -&gt; <strong>复用开漏输出</strong>（并使能内部或使用外部上拉电阻）。</li><li><strong>ADC读取电压</strong> -&gt; <strong>模拟模式</strong>。</li><li><strong>USART串口发送</strong> -&gt; <strong>复用推挽输出</strong>。</li><li><strong>USART串口接收</strong> -&gt; <strong>浮空输入</strong>（或上拉输入，取决于空闲状态）。</li></ol><h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><h3 id="CPU时序基础知识"><a href="#CPU时序基础知识" class="headerlink" title="CPU时序基础知识"></a>CPU时序基础知识</h3><ul><li><strong>振荡周期</strong>：为单片机提供定时信号的振荡源的周期（晶振周期）。例如，外接12MHz晶振时，振荡周期 &#x3D; ( 1 &#x2F; 12 )µs。</li><li><strong>状态周期</strong>：2个振荡周期为1个状态周期，用S表示。例如，12MHz晶振时，状态周期 &#x3D; ( 1 &#x2F; 6 )µs。</li><li><strong>机器周期</strong>：1个机器周期含6个状态周期（12个振荡周期）。例如，12MHz晶振时，机器周期 &#x3D; 1µs。</li><li><strong>指令周期</strong>：完成1条指令所占用的全部时间，以机器周期为单位。例如，12MHz晶振时，指令周期 &#x3D; 1~4µs（取决于指令的复杂程度）。</li><li><strong>12MHz晶振</strong>：优点在于计算<strong>定时器</strong>的初值非常方便，机器周期是整数的1µs。缺点是产生的<strong>串口通信波特率</strong>存在较大误差，可能导致通信不稳定。</li><li><strong>11.0592MHz晶振</strong>：优点在于可以产生<strong>非常精确的串口波特率</strong>，误差极小，通信可靠。缺点是计算<strong>定时器</strong>初值时会得到小数，不够直观。</li></ul><h3 id="分频"><a href="#分频" class="headerlink" title="分频"></a>分频</h3><ol><li>核心概念：什么是“分频”？</li></ol><p>你可以把单片机内核看作一个高速工作的核心引擎。晶振产生的原始时钟频率（比如11.0592MHz）就像是引擎的最高转速，这个速度非常快。如果让定时器直接以这个速度计数，会计数得飞快，很难用于精确控制较长的时间。</p><p>因此，需要一个“减速器”或“变速箱”，让定时器的计数速度慢下来。这个“减速器”就是 <strong>分频器</strong>。</p><ul><li><strong>“12T”模式</strong>：意思就是 <strong>将系统时钟进行12分频后，再提供给定时器作为其时钟源</strong>。<ul><li>也就是说，系统主时钟跳动12次，定时器的计数器才增加1。</li></ul></li></ul><ol start="2"><li>对机器周期的影响</li></ol><p>这是理解51单片机时序的基础。在标准的51架构中：</p><ul><li><strong>机器周期 &#x3D; 12个时钟周期</strong>。</li></ul><p>这正好与“定时器时钟12T”相对应。在标准51模式下，<strong>1个机器周期</strong> 的定义就是CPU完成一个基本操作（如取指令、译码）所需要的时间，它由 <strong>12个时钟振荡周期</strong> 组成。</p><p>所以，<strong>“定时器时钟12T” 也常被称为 “12时钟模式” 或 “标准51模式”</strong>。在这种模式下，定时器的计数频率是晶振频率的 1&#x2F;12。</p><ol start="3"><li>具体计算示例</li></ol><p>让我们用具体的数字来看，这样更清晰。</p><ul><li><strong>假设外接晶振频率 (Fosc) &#x3D; 12MHz</strong></li><li><strong>系统时钟周期 (振荡周期)</strong> &#x3D; 1 &#x2F; 12MHz &#x3D; 1&#x2F;12 µs</li><li><strong>在12T模式下，定时器的时钟频率</strong> &#x3D; Fosc &#x2F; 12 &#x3D; 12MHz &#x2F; 12 &#x3D; 1MHz</li><li><strong>定时器的计数周期 (即机器周期)</strong> &#x3D; 1 &#x2F; 1MHz &#x3D; <strong>1µs</strong></li></ul><p><strong>这意味着什么？</strong><br>这意味着在12T模式下，定时器每过 <strong>1微秒</strong>，其计数值才会加1。这为我们提供了非常方便的时间基准。比如要定时1ms，只需要计数1000次即可。</p><ol start="4"><li>对比：12T模式 vs 1T模式（高速模式）</li></ol><p>很多现代的增强型51单片机（如STC的很多型号）为了提升性能，引入了 <strong>“1T”模式</strong>。</p><ul><li><strong>“1T”模式</strong>：意思是 <strong>不分频，定时器直接使用系统时钟作为其时钟源</strong>。<ul><li>也就是说，系统主时钟跳动1次，定时器的计数器就增加1。</li></ul></li></ul><p>同样以12MHz晶振为例：</p><ul><li><strong>在1T模式下，定时器的时钟频率</strong> &#x3D; Fosc &#x3D; 12MHz</li><li><strong>定时器的计数周期</strong> &#x3D; 1 &#x2F; 12MHz ≈ 0.083µs</li></ul><p><strong>对比结论：</strong><br>在相同的晶振频率下，1T模式的定时器计数速度是12T模式的 <strong>12倍</strong>。</p><ul><li><strong>优点</strong>：速度极快，精度更高，可以实现更短的定时和更高速的波特率。</li><li><strong>缺点</strong>：对于需要长时间定时的场景，定时器溢出会非常频繁。</li></ul><p>总结</p><ul><li><strong>定时器时钟12T</strong>：指的是<strong>12分频模式</strong>，是<strong>传统51单片机的标准模式</strong>。</li><li><strong>工作原理</strong>：定时器每接收12个系统时钟脉冲，才计数1次。</li><li><strong>直接影响</strong>：它决定了<strong>机器周期</strong>，并使得定时器的计数速度变慢，更容易用于控制我们日常感知的“秒”、“毫秒”级别的时间。</li><li><strong>公式</strong>：在12T模式下，<code>机器周期 = 12 / Fosc</code>，<code>定时器计数频率 = Fosc / 12</code>。</li></ul><p>简单来说，<strong>12T就是一个为了适应人类时间感知和早期CPU性能而设置的“减速档”，而1T则是为了追求高性能的“高速档”</strong>。在编程时，你需要根据自己单片机的数据手册，确认定时器工作在哪种模式，才能正确计算初值。</p><h3 id="机器周期与时钟频率的关系"><a href="#机器周期与时钟频率的关系" class="headerlink" title="机器周期与时钟频率的关系"></a>机器周期与时钟频率的关系</h3><ul><li><strong>机器周期</strong>是单片机执行操作的基本时间单位，计算公式为： <strong>机器周期 &#x3D; 1 &#x2F; 单片机的时钟频率</strong>。</li><li>51单片机内部时钟频率是外部晶振频率的12分频。也就是说，如果外部晶振频率为 fosc，则内部时钟频率为 fosc &#x2F; 12 。</li><li>例如，当使用12MHz外部晶振时：<ul><li>内部时钟频率 &#x3D; 12MHz &#x2F; 12 &#x3D; 1MHz。</li><li>机器周期 &#x3D; 1 &#x2F; 1MHz &#x3D; 1µs。</li></ul></li></ul><h3 id="定时器初值的计算"><a href="#定时器初值的计算" class="headerlink" title="定时器初值的计算"></a>定时器初值的计算</h3><p>定时器工作时，从初值开始向上计数，当计数到65536（16位定时器的最大值，即 ( 2^{16} )）时溢出，产生中断。要定时一定时间，需要计算所需的计数值 ( N )：N &#x3D; 定时时间&#x2F;机器周期</p><ul><li>初值 ( X ) 的计算公式为： ( X &#x3D; 65536 - N )<br>（因为计数器从初值开始计数到65536溢出，所以需要减去 ( N )）。</li></ul><p><strong>示例：定时1ms</strong></p><ul><li>使用12MHz晶振，机器周期 &#x3D; 1µs。</li><li>需要定时1ms，所以 ( N &#x3D; 1ms &#x2F; 1µs &#x3D; 1000 )。</li><li>初值 ( X &#x3D; 65536 - 1000 &#x3D; 64536 )。</li><li>将64536转换为十六进制：64536 &#x3D; 0xFC18。</li><li>因此，定时器初值设置为：<br>( THx &#x3D; 0xFC )（高字节），<br>( TLx &#x3D; 0x18 )（低字节）。</li></ul><h3 id="定时器波特率初值的计算"><a href="#定时器波特率初值的计算" class="headerlink" title="定时器波特率初值的计算"></a><strong>定时器波特率初值的计算</strong></h3><p>在51单片机中，串口通信的波特率通常由<strong>定时器1（T1）</strong> 在<strong>工作模式2（8位自动重装模式）</strong> 下产生。这是最常用且最精确的方式。</p><p>其波特率计算公式为：<strong>波特率 &#x3D; (2^SMOD &#x2F; 32) × (定时器1的溢出率)</strong></p><ul><li><strong>SMOD</strong>：是<code>PCON</code>寄存器（电源控制寄存器）的最高位。<code>SMOD=1</code>时，波特率加倍；<code>SMOD=0</code>时，波特率不加倍。通常为了稳定性，我们取 <code>SMOD = 0</code>。</li><li><strong>定时器1的溢出率</strong>：即定时器1每秒溢出的次数。</li></ul><p>由于我们使用<strong>模式2（自动重装模式）</strong>，定时器1的溢出率计算公式为：<strong>定时器1的溢出率 &#x3D; Fosc &#x2F; (12 × [256 - TH1])</strong></p><ul><li><strong>Fosc</strong>：系统晶振频率。</li><li><strong>TH1</strong>：定时器1的高8位寄存器，也是我们要求解的<strong>波特率初值</strong>。</li></ul><p>将两个公式合并，得到：<strong>波特率 &#x3D; (2^SMOD × Fosc) &#x2F; (384 × [256 - TH1])</strong></p><p>现在我们从这个公式中解出 <strong>TH1</strong>（即波特率初值）：</p><ol><li><code>波特率 × 384 × (256 - TH1) = 2^SMOD × Fosc</code></li><li><code>256 - TH1 = (2^SMOD × Fosc) / (384 × 波特率)</code></li><li><strong>TH1 &#x3D; 256 - (2^SMOD × Fosc) &#x2F; (384 × 波特率)</strong></li></ol><p><strong>示例1：使用11.0592MHz晶振，目标波特率9600bps，SMOD&#x3D;0</strong></p><ol><li><strong>列出已知条件</strong>：<ul><li>Fosc &#x3D; 11,059,200 Hz</li><li>波特率 &#x3D; 9600</li><li>SMOD &#x3D; 0 → 2^SMOD &#x3D; 1</li></ul></li><li><strong>代入公式</strong>：<br><code>TH1 = 256 - (1 × 11059200) / (384 × 9600)</code></li><li><strong>计算</strong>：<ul><li>先计算分母：<code>384 × 9600 = 3,686,400</code></li><li>计算除法：<code>11,059,200 / 3,686,400 = 3</code></li><li>最终结果：<code>TH1 = 256 - 3 = 253</code></li></ul></li><li><strong>得到初值</strong>：<br><strong>TH1 &#x3D; 253 (0xFD)</strong></li></ol><p><strong>结论</strong>：这就是为什么11.0592MHz被称为”串口通信的魔法晶振”，因为它计算常用波特率时，TH1总是整数，没有误差！</p><p><strong>示例2：使用12.000MHz晶振，目标波特率9600bps，SMOD&#x3D;0</strong></p><ol><li><strong>列出已知条件</strong>：<ul><li>Fosc &#x3D; 12,000,000 Hz</li><li>波特率 &#x3D; 9600</li><li>SMOD &#x3D; 0 → 2^SMOD &#x3D; 1</li></ul></li><li><strong>代入公式</strong>：<br><code>TH1 = 256 - (1 × 12000000) / (384 × 9600)</code></li><li><strong>计算</strong>：<ul><li>分母：<code>384 × 9600 = 3,686,400</code></li><li>计算除法：<code>12,000,000 / 3,686,400 ≈ 3.2552</code></li><li>最终结果：<code>TH1 = 256 - 3.2552 ≈ 252.7448</code></li></ul></li><li><strong>取整处理</strong>：<br>我们只能给TH1赋予整数值，所以通常取 <strong>TH1 &#x3D; 253 (0xFD)</strong>。</li><li><strong>计算误差</strong>（非常重要！）：<br>现在我们用实际值反算一下波特率，看看误差有多大。<br><code>实际波特率 = (1 × 12000000) / (384 × [256 - 253]) = 12,000,000 / (384 × 3) = 12,000,000 / 1152 ≈ 10416.7 bps</code><br><strong>误差率 &#x3D; (10416.7 - 9600) &#x2F; 9600 × 100% ≈ 8.5%</strong></li></ol><p><strong>结论</strong>：使用12MHz晶振时，波特率存在约8.5%的误差，这已经远超串口通信允许的误差范围（通常要求&lt;3%），<strong>极易导致通信失败</strong>。</p><h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p>ULN2003 是一款常用的<strong>达林顿晶体管阵列芯片</strong>，常用于<strong>51单片机</strong>或其他微控制器的<strong>输出驱动扩展</strong>，主要用于驱动较大电流或较高电压的负载，如继电器、步进电机、LED显示、小型直流电机等。</p><hr><h3 id="ULN2003-的基本结构"><a href="#ULN2003-的基本结构" class="headerlink" title="ULN2003 的基本结构"></a>ULN2003 的基本结构</h3><ul><li><p><strong>7路达林顿管阵列</strong>：每路可独立控制。</p></li><li><p><strong>每路结构</strong>：</p><p><img src="https://live2d-api-jet.vercel.app/model/image/51/ULN2003.png" srcset="/img/loading.gif" lazyload></p><ul><li>输入引脚（B1~B7）</li><li>输出引脚（C1~C7）</li><li>内置<strong>2.7kΩ 基极电阻</strong>，可直接与5V TTL&#x2F;CMOS电平（如51单片机I&#x2F;O口）连接。</li><li>内置<strong>续流二极管（COM端）</strong>，用于感性负载（如继电器、电机）的反向电动势保护。</li></ul></li></ul><hr><h3 id="在51单片机中的典型用法"><a href="#在51单片机中的典型用法" class="headerlink" title="在51单片机中的典型用法"></a>在51单片机中的典型用法</h3><p>连接方式：</p><ul><li><strong>输入（B1~B7）</strong> → 连接51单片机的I&#x2F;O口（如P1口）</li><li><strong>输出（C1~C7）</strong> → 连接负载（如继电器线圈、LED灯组、步进电机绕组）</li><li><strong>COM端</strong> → 接负载电源正极（如+12V、+24V），用于续流保护。</li></ul><p>示例：驱动继电器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 51单片机代码示例：控制ULN2003驱动继电器</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;reg51.h&gt;</span></span><br><br>sbit RELAY = P1^<span class="hljs-number">0</span>;  <span class="hljs-comment">// 假设P1.0接ULN2003的B1</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        RELAY = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 输出高电平，ULN2003导通，继电器吸合</span><br>        Delay_ms(<span class="hljs-number">1000</span>);<br>        RELAY = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 输出低电平，ULN2003截止，继电器释放</span><br>        Delay_ms(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="模拟钢琴"><a href="#模拟钢琴" class="headerlink" title="模拟钢琴"></a>模拟钢琴</h3><ul><li><p><strong>键盘与音符</strong></p><p><img src="https://live2d-api-jet.vercel.app/model/image/51/SheetMusic.png" srcset="/img/loading.gif" lazyload></p><ul><li><p><strong>音高</strong>：上面图中每个<strong>字组</strong>中相同的音之间相差<strong>八度</strong>的关系，每个字组从<strong>上面</strong>看相邻的两个音之间是半音的关系，而从<strong>下面</strong>看相邻的两个音之间是全音的关系。</p></li><li><p><strong>简谱</strong>：想要表示全部<strong>白键</strong>的音，可以由<strong>小字1组</strong>中的音加八度或减八度具体表现为是数字的上方是加点还是在数字的下方加点；想要表示<strong>黑键</strong>的音，可以使用升音符号：<strong>#<strong>和降音符号：<strong>b</strong>,两个符号要不</strong>升高半音</strong>要不<strong>减少半音</strong>。</p></li><li><p><strong>音符</strong>：音符的时长，分为全音符、二分音符、四分音符、八分音符、十六分音符、三十二分音符，一般以四分音符为基准，假设四分音符是500ms，那么二分音符就是1s、八分音符就是250ms以此类推。</p><p><img src="https://live2d-api-jet.vercel.app/model/image/51/Notation.png" srcset="/img/loading.gif" lazyload></p></li><li><p><strong>时长</strong>：如上面图中<strong>黄色</strong>圈中音符后面的黑色短横线代表的是延长一个四分音符的时长，简谱上的一个音符（数字）表示的是四分音符，二这种后面加了横线的表示的是二分音符；<strong>红色</strong>圈中的音符下面的黑色短横线代表的是延长时长的二分之一倍，如果音符的右下角有一个小点（<strong>附点</strong>）表示在原来音符的基础上加上半个音符，例如原本是四分音符有<strong>附点</strong>后加八分音符，表示时间变为原理的1.5倍。</p></li><li><p><strong>拍</strong>：如上图左上角的四分之一表示的是以四分音符为一拍每小节有四拍。</p></li><li><p><strong>延音线</strong>：将两个相同的音合并为一个音。</p></li></ul></li><li><p><strong>音符与频率对照</strong></p><img src="https://live2d-api-jet.vercel.app/model/image/51/NotesAndFrequencies.png" srcset="/img/loading.gif" lazyload style="zoom:67%"><p>以小字组中的a为基准频率，它的频率为440，那么A的频率为220，a1的频率为880；在A和a中(有12个音)的频率是以等比数列进行平分的，那么B的频率就可以表示为A<em>2^(1&#x2F;12);有了*<em>频率</em></em>(Hz)，我们就可以计算它的<strong>振荡周期</strong>(1&#x2F;频率)(s)，这里我们要将它转换成为<strong>微秒</strong>，所以要×10^6,在这里如果我们的</p></li></ul><p>好的，非常乐意为您详细讲解51单片机的中断系统。我们将按照您提出的五个部分进行结构化介绍，力求清晰透彻。</p><h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p><strong>核心概念：</strong> 中断是指当CPU正在执行主程序时，单片机内部或外部发生了某一紧急事件（如定时器溢出、有按键按下），请求CPU暂时中止当前的工作，转去处理这个紧急事件。处理完毕后，CPU再返回原来被中断的地方，继续执行主程序。这极大地提高了CPU的效率，并允许单片机及时响应外部事件。</p><h3 id="中断结构"><a href="#中断结构" class="headerlink" title="中断结构"></a>中断结构</h3><p>51单片机的中断系统结构可以看作一个由<strong>中断源、中断标志、中断允许、中断优先级</strong>和<strong>硬件查询逻辑</strong>组成的处理流水线。</p><img src="https://live2d-api-jet.vercel.app/model/image/51/Interruption_Structure.png" srcset="/img/loading.gif" lazyload style="zoom:67%"><p><strong>中断源</strong><br>标准51单片机（如8051）通常有<strong>5个</strong>中断源，增强型51（如STC89C52）有<strong>6个</strong>或更多。它们是中断请求的“发源地”。</p><img src="https://live2d-api-jet.vercel.app/model/image/51/Interrupt_Trigger.png" srcset="/img/loading.gif" lazyload style="zoom:67%"><p><strong>中断向量地址</strong><br>当CPU响应某个中断后，程序会自动跳转到一个固定的地址去执行对应的中断服务程序。这个固定的地址称为<strong>中断向量地址</strong>。</p><table><thead><tr><th align="left">中断源</th><th align="left">中断向量地址</th></tr></thead><tbody><tr><td align="left">外部中断0 (INT0)</td><td align="left">0003H</td></tr><tr><td align="left">定时器&#x2F;计数器0 (T0)</td><td align="left">000BH</td></tr><tr><td align="left">外部中断1 (INT1)</td><td align="left">0013H</td></tr><tr><td align="left">定时器&#x2F;计数器1 (T1)</td><td align="left">001BH</td></tr><tr><td align="left">串行口 (TI&#x2F;RI)</td><td align="left">0023H</td></tr><tr><td align="left">定时器&#x2F;计数器2 (T2)</td><td align="left">002BH</td></tr></tbody></table><p><strong>中断处理流程</strong></p><ul><li><strong>中断发生</strong>：某个中断源满足条件，其对应的<strong>中断请求标志位</strong>被硬件置1。</li><li><strong>中断响应</strong>：如果总中断和该分中断都已被<strong>允许</strong>（EA&#x3D;1， EXx&#x2F;ETx&#x2F;ES&#x3D;1），且当前没有更高优先级的中断正在执行，CPU会在执行完当前指令后响应中断。</li><li><strong>硬件操作</strong>：CPU响应后，会进行以下操作：<ol><li>将下一条指令的地址（断点）压入堆栈保护。</li><li>关闭中断（相当于硬件执行 <code>CLR EA</code>，防止后续干扰）。</li><li>根据中断源，跳转到对应的中断向量地址。</li></ol></li><li><strong>执行中断服务程序</strong>：程序员在向量地址处编写中断服务程序。</li><li><strong>中断返回</strong>：执行到 <code>RETI</code> 指令时，CPU会：<ol><li>将断点地址从堆栈弹出，使程序返回主程序。</li><li>重新开放中断（相当于硬件执行 <code>SETB EA</code>）</li></ol></li></ul><hr><h3 id="中断寄存器"><a href="#中断寄存器" class="headerlink" title="中断寄存器"></a>中断寄存器</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/Interrupt_Register.png" srcset="/img/loading.gif" lazyload style="zoom:67%"><p>中断系统的所有行为都是通过对特殊功能寄存器（SFR）的位进行设置来控制的。主要有两个关键寄存器：</p><p><strong>中断允许寄存器</strong></p><ul><li><p><strong>作用</strong>：像一个总开关和多个分路开关，控制着整个中断系统的开启与关闭。</p></li><li><p><strong>位定义</strong> (地址：0xA8， 可位寻址)：</p><table><thead><tr><th align="left">位</th><th align="left">D7</th><th align="left">D6</th><th align="left">D5</th><th align="left">D4</th><th align="left">D3</th><th align="left">D2</th><th align="left">D1</th><th align="left">D0</th></tr></thead><tbody><tr><td align="left">符号</td><td align="left">EA</td><td align="left">-</td><td align="left">ET2</td><td align="left">ES</td><td align="left">ET1</td><td align="left">EX1</td><td align="left">ET0</td><td align="left">EX0</td></tr><tr><td align="left">说明</td><td align="left"><strong>总开关</strong></td><td align="left">保留</td><td align="left">T2中断允许</td><td align="left">串口中断允许</td><td align="left">T1中断允许</td><td align="left">外部中断1允许</td><td align="left">T0中断允许</td><td align="left">外部中断0允许</td></tr></tbody></table></li><li><p><strong>详细说明</strong>：</p><ul><li><strong>EA</strong>：总中断允许位。<code>EA = 1</code>，开放所有中断；<code>EA = 0</code>，禁止所有中断（所有中断请求都被忽略）。</li><li><strong>EX0&#x2F;EX1</strong>：外部中断0&#x2F;1允许位。<code>1</code>为允许，<code>0</code>为禁止。</li><li><strong>ET0&#x2F;ET1</strong>：定时器0&#x2F;1中断允许位。<code>1</code>为允许，<code>0</code>为禁止。</li><li><strong>ES</strong>：串行口中断允许位。<code>1</code>为允许，<code>0</code>为禁止。</li><li><strong>ET2</strong>：定时器2中断允许位（增强型51才有）。</li></ul></li></ul><ul><li><strong>示例</strong>：要使用外部中断0和定时器1中断，需要设置：<code>EA = 1; EX0 = 1; ET1 = 1;</code></li></ul><p><strong>串行口控制寄存器</strong></p><ul><li><p><strong>作用</strong>：主要用于设置串行口的工作方式（如8位UART、9位UART等）和<strong>串行口中断的标志位</strong>。串行口中断是唯一一个需要<strong>软件手动清除</strong>标志位的中断。</p></li><li><p><strong>位定义</strong> (地址：0x98， 可位寻址)：</p><table><thead><tr><th align="left">位</th><th align="left">D7</th><th align="left">D6</th><th align="left">D5</th><th align="left">D4</th><th align="left">D3</th><th align="left">D2</th><th align="left">D1</th><th align="left">D0</th></tr></thead><tbody><tr><td align="left">符号</td><td align="left">SM0</td><td align="left">SM1</td><td align="left">SM2</td><td align="left">REN</td><td align="left">TB8</td><td align="left">RB8</td><td align="left"><strong>TI</strong></td><td align="left"><strong>RI</strong></td></tr></tbody></table></li><li><p><strong>与中断相关的位详细说明</strong>：</p><ul><li><strong>TI</strong>：<strong>串行口发送中断请求标志位</strong>。<ul><li>当串行口发送完一帧数据后，由<strong>硬件自动置1</strong>。</li><li><strong>必须由软件手动清0</strong>（<code>TI = 0;</code>）。</li></ul></li><li><strong>RI</strong>：<strong>串行口接收中断请求标志位</strong>。<ul><li>当串行口接收完一帧数据后，由<strong>硬件自动置1</strong>。</li><li><strong>必须由软件手动清0</strong>（<code>RI = 0;</code>）。</li></ul></li></ul></li><li><p><strong>工作机制</strong>：<br>串行口中断比较特殊，<strong>TI和RI共用一个中断向量（0023H）</strong>。这意味着，无论是发送完成还是接收完成，都会触发同一个串行口中断。<br>因此，在编写串行口中断服务程序时，<strong>必须首先通过查询TI和RI的标志位，来判断究竟是发送引起的中断还是接收引起的中断</strong>，然后分别进行处理，并且在处理完毕后<strong>手动清除对应的标志位</strong>。</p></li></ul><p><strong>定时器控制寄存器</strong></p><ul><li><p><strong>作用</strong>：主要用于控制定时器&#x2F;计数器的工作模式，但其低4位与外部中断的<strong>触发方式</strong>密切相关。</p></li><li><p><strong>位定义</strong> (地址：0x88， 可位寻址)：</p><table><thead><tr><th align="left">位</th><th align="left">D7</th><th align="left">D6</th><th align="left">D5</th><th align="left">D4</th><th align="left">D3</th><th align="left">D2</th><th align="left">D1</th><th align="left">D0</th></tr></thead><tbody><tr><td align="left">符号</td><td align="left">TF1</td><td align="left">TR1</td><td align="left">TF0</td><td align="left">TR0</td><td align="left">IE1</td><td align="left">IT1</td><td align="left">IE0</td><td align="left">IT0</td></tr></tbody></table></li><li><p><strong>相关位说明</strong>：</p><ul><li><strong>IT0&#x2F;IT1</strong>：外部中断0&#x2F;1触发方式控制位。<ul><li><code>ITx = 0</code>：<strong>低电平触发</strong>。只要P3.2&#x2F;P3.3引脚为低电平，就认为有中断请求。</li><li><code>ITx = 1</code>：<strong>下降沿触发</strong>。只有当P3.2&#x2F;P3.3引脚的电平发生从高到低的跳变时，才认为有中断请求。</li></ul></li><li><strong>IE0&#x2F;IE1</strong>：外部中断0&#x2F;1请求标志位。当CPU检测到有效的中断信号时，由硬件自动置1。当CPU响应中断并跳转到中断服务程序后，硬件会自动将其清0（对于边沿触发方式）。</li></ul></li></ul><hr><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>51单片机具有<strong>两个可编程的优先级</strong>：高优先级和低优先级。通过<strong>中断优先级寄存器</strong> 进行设置。</p><p><strong>中断优先级寄存器</strong></p><ul><li><p><strong>作用</strong>：设置每个中断源的优先级。</p></li><li><p><strong>位定义</strong> (地址：0xB8， 可位寻址)：</p><table><thead><tr><th align="left">位</th><th align="left">D7</th><th align="left">D6</th><th align="left">D5</th><th align="left">D4</th><th align="left">D3</th><th align="left">D2</th><th align="left">D1</th><th align="left">D0</th></tr></thead><tbody><tr><td align="left">符号</td><td align="left">-</td><td align="left">-</td><td align="left">PT2</td><td align="left">PS</td><td align="left">PT1</td><td align="left">PX1</td><td align="left">PT0</td><td align="left">PX0</td></tr></tbody></table></li><li><p><strong>详细说明</strong>：</p><ul><li><strong>PX0</strong>：外部中断0优先级设定位。</li><li><strong>PT0</strong>：定时器0优先级设定位。</li><li><strong>PX1</strong>：外部中断1优先级设定位。</li><li><strong>PT1</strong>：定时器1优先级设定位。</li><li><strong>PS</strong>：串行口优先级设定位。</li><li><strong>PT2</strong>：定时器2优先级设定位。</li><li><strong>规则</strong>：将相应位设为 <code>1</code>，则该中断为<strong>高优先级</strong>；设为 <code>0</code>，则为<strong>低优先级</strong>。</li></ul></li></ul><p><strong>优先级处理规则</strong></p><ul><li><strong>不同优先级的中断同时发生</strong>：先响应高优先级的中断。</li><li><strong>相同优先级的中断同时发生</strong>：CPU会按照一个内部的<strong>自然优先级（查询顺序）</strong> 来决定先响应哪个。这个顺序是固定的：<br><code>INT0 -&gt; T0 -&gt; INT1 -&gt; T1 -&gt; TI/RI -&gt; T2</code></li><li><strong>中断嵌套</strong>：<ul><li>低优先级的中断服务程序可以被高优先级的中断所中断。</li><li>高优先级的中断服务程序不能被任何中断所中断。</li><li>相同优先级的中断不能相互嵌套。</li></ul></li></ul><hr><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>这部分是程序员编写代码的核心。</p><p><strong>中断服务程序的编写</strong><br>在C语言中，我们使用 <code>interrupt</code> 关键字和中断号来定义一个函数为中断服务程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数返回值 函数名() interrupt 中断号 [using 工作寄存器组]</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">My_ISR</span><span class="hljs-params">()</span> interrupt 0 <span class="hljs-comment">// 外部中断0的服务程序</span><br>&#123;<br>    <span class="hljs-comment">// 中断处理代码</span><br>    <span class="hljs-comment">// ... </span><br>    <span class="hljs-comment">// 无需手动清除标志位（对于边沿触发的外部中断和定时器中断，硬件会自动清除）</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>中断号对应表</strong>：</p><table><thead><tr><th align="left">中断源</th><th align="left">中断号</th></tr></thead><tbody><tr><td align="left">外部中断0 (INT0)</td><td align="left">0</td></tr><tr><td align="left">定时器0 (T0)</td><td align="left">1</td></tr><tr><td align="left">外部中断1 (INT1)</td><td align="left">2</td></tr><tr><td align="left">定时器1 (T1)</td><td align="left">3</td></tr><tr><td align="left">串行口 (TI&#x2F;RI)</td><td align="left">4</td></tr><tr><td align="left">定时器2 (T2)</td><td align="left">5</td></tr></tbody></table><p><strong>重要注意事项</strong></p><ul><li><strong>代码要简短</strong>：中断服务程序应尽可能短小精悍，只处理最紧急的任务，避免长时间占用CPU。</li><li><strong>标志位处理</strong>：<ul><li>对于外部中断（边沿触发）和定时器溢出中断，CPU响应后硬件会<strong>自动清除</strong>标志位（IEx, TFx）。</li><li>对于<strong>串行口中断</strong>，硬件<strong>不会自动清除</strong>TI和RI标志位！必须在中断服务程序中用软件判断并清除：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UART_ISR</span><span class="hljs-params">()</span> interrupt 4<br>&#123;<br>    <span class="hljs-keyword">if</span> (RI == <span class="hljs-number">1</span>) &#123;<br>        RI = <span class="hljs-number">0</span>; <span class="hljs-comment">// 软件清除接收标志</span><br>        <span class="hljs-comment">// ... 处理接收到的数据</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (TI == <span class="hljs-number">1</span>) &#123;<br>        TI = <span class="hljs-number">0</span>; <span class="hljs-comment">// 软件清除发送标志</span><br>        <span class="hljs-comment">// ... 处理发送完成后的工作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>保护现场</strong>：如果中断服务程序中会改变主程序中正在使用的寄存器（如ACC, PSW等），应在进入中断时压栈保护，退出中断前出栈恢复。</li></ul><hr><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>外部中断是连接单片机与外部世界的重要桥梁。</p><p><strong>触发方式</strong></p><ul><li><strong>电平触发</strong>：<ul><li>设置 <code>ITx = 0</code>。</li><li>只要 <code>INTx</code> 引脚为低电平，中断请求就持续有效。</li><li><strong>优点</strong>：响应及时。</li><li><strong>缺点</strong>：如果在CPU响应中断并执行服务程序期间，低电平信号还没有撤销，CPU在退出中断后会<strong>立刻再次响应</strong>同一个中断，导致程序“卡死”在中断里。因此，使用电平触发时，必须确保低电平的持续时间<strong>非常短</strong>，通常需要硬件电路配合。</li></ul></li><li><strong>边沿触发</strong>：<ul><li>设置 <code>ITx = 1</code>。</li><li>只有当 <code>INTx</code> 引脚检测到从高到低的<strong>跳变（下降沿）</strong> 时，才产生一次有效的中断请求。</li><li><strong>优点</strong>：无论低电平持续多久，只产生一次中断，避免了重复触发的问题。这是<strong>最常用</strong>的方式。</li><li><strong>缺点</strong>：如果两次下降沿间隔太短（在前一个中断服务程序执行完之前就发生了），后一个中断可能会被丢失。</li></ul></li></ul><p><strong>应用实例：按键控制LED</strong><br>使用外部中断0，下降沿触发，每次按键翻转一次LED状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;reg52.h&gt;</span></span><br>sbit LED = P1^<span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    EA = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 打开总中断开关</span><br>    EX0 = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 打开外部中断0开关</span><br>    IT0 = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 设置外部中断0为下降沿触发</span><br><br>    LED = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 初始化LED熄灭</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 主程序可以执行其他任务，LED由中断独立控制</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 外部中断0服务程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EX0_ISR</span><span class="hljs-params">()</span> interrupt 0 &#123;<br>    LED = !LED;  <span class="hljs-comment">// 按键一次，LED状态翻转一次</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器&#x2F;计数器"></a>定时器&#x2F;计数器</h2><h3 id="TMOD-寄存器简介"><a href="#TMOD-寄存器简介" class="headerlink" title="TMOD 寄存器简介"></a>TMOD 寄存器简介</h3><p>TMOD 是一个8位的特殊功能寄存器，地址为 0x89。它用于控制和设置<strong>定时器&#x2F;计数器0</strong> 和 <strong>定时器&#x2F;计数器1</strong> 的工作模式。</p><p>它的结构如下：</p><table><thead><tr><th align="left">D7</th><th align="left">D6</th><th align="left">D5</th><th align="left">D4</th><th align="left">D3</th><th align="left">D2</th><th align="left">D1</th><th align="left">D0</th></tr></thead><tbody><tr><td align="left"><strong>GATE</strong></td><td align="left"><strong>C&#x2F;T</strong></td><td align="left"><strong>M1</strong></td><td align="left"><strong>M0</strong></td><td align="left"><strong>GATE</strong></td><td align="left"><strong>C&#x2F;T</strong></td><td align="left"><strong>M1</strong></td><td align="left"><strong>M0</strong></td></tr><tr><td align="left">← <strong>定时器1</strong> →</td><td align="left">← <strong>定时器0</strong> →</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li><strong>高4位 (D7-D4)</strong>：用于控制<strong>定时器1</strong>。</li><li><strong>低4位 (D3-D0)</strong>：用于控制<strong>定时器0</strong>。</li></ul><p>每个定时器的4位含义完全相同：</p><ul><li><strong>GATE</strong>：门控位。<ul><li><code>0</code> - 定时器的启动仅由 <strong>TRx</strong> (TCON寄存器中的位) 控制。</li><li><code>1</code> - 定时器的启动由 <strong>TRx</strong> 和 <strong>外部中断引脚 (INTx)</strong> 共同控制。只有当INTx引脚为高电平<strong>且</strong>TRx&#x3D;1时，定时器才开始计数。常用于测量外部脉冲的宽度。</li></ul></li><li><strong>C&#x2F;T</strong>：定时器或计数器模式选择位。<ul><li><code>0</code> - <strong>定时器模式</strong>。对单片机内部的机器周期进行计数。</li><li><code>1</code> - <strong>计数器模式</strong>。对来自外部引脚 (T0&#x2F;P3.4 或 T1&#x2F;P3.5) 的下降沿脉冲进行计数。</li></ul></li><li><strong>M1</strong> 和 <strong>M0</strong>：工作模式选择位。这两位组合起来定义了四种工作模式。</li></ul><hr><h3 id="四种工作模式详解-M1-M0"><a href="#四种工作模式详解-M1-M0" class="headerlink" title="四种工作模式详解 (M1, M0)"></a>四种工作模式详解 (M1, M0)</h3><p><strong>模式 0 (M1&#x3D;0, M0&#x3D;0)：13位定时器&#x2F;计数器</strong></p><ul><li><strong>工作原理</strong>：<ul><li>使用了 <strong>TLx</strong> 的低5位和 <strong>THx</strong> 的全部8位，共同组成一个13位的计数器（2^13 &#x3D; 8192）。</li><li>TLx的高3位无效。</li></ul></li><li><strong>特点</strong>：<ul><li>这是为了兼容早期的8048单片机而设计的，计数值范围小（0~8191）。</li><li><strong>现在已基本被淘汰</strong>，不建议在新项目中使用。</li></ul></li><li><strong>初值计算</strong>：<code>初值 = 8192 - N</code> (N为需要的计数值)</li></ul><p><strong>模式 1 (M1&#x3D;0, M0&#x3D;1)：16位定时器&#x2F;计数器</strong></p><ul><li><strong>工作原理</strong>：<ul><li><strong>TLx</strong> 和 <strong>THx</strong> 全部使用，组成一个标准的16位计数器（2^16 &#x3D; 65536）。这是<strong>最常用</strong>的模式之一。</li></ul></li><li><strong>特点</strong>：<ul><li>计数值范围大（0~65535）。</li><li>需要<strong>手动重装初值</strong>。当计数器溢出后，TLx和THx会清零，如果需要再次定时，必须在中断服务程序中用代码重新写入初值。</li></ul></li><li><strong>适用场景</strong>：需要较长时间定时的场合，如精确延时1ms、10ms等。</li><li><strong>初值计算</strong>：<code>初值 = 65536 - N</code> (N为需要的计数值)<ul><li>例如，用12MHz晶振，机器周期为1us，定时1ms需要计数1000次。则初值 &#x3D; 65536 - 1000 &#x3D; 64536 &#x3D; 0xFC18。所以 <code>TH = 0xFC</code>, <code>TL = 0x18</code>。</li></ul></li></ul><p><strong>模式 2 (M1&#x3D;1, M0&#x3D;0)：8位自动重装定时器&#x2F;计数器</strong></p><ul><li><strong>工作原理</strong>：<ul><li><strong>TLx</strong> 作为8位计数器（2^8 &#x3D; 256）。</li><li><strong>THx</strong> 作为存放<strong>重装值</strong>的寄存器。</li><li>当TLx计数溢出时，不仅会产生溢出标志位（TFx），<strong>硬件还会自动将THx中的值重新装入TLx</strong>，然后立即开始下一轮的计数。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>自动重装</strong>，无需软件干预，定时非常精确，没有因重装指令带来的时间误差。</li><li>计数值范围小（0~255）。</li></ul></li><li><strong>适用场景</strong>：需要<strong>精确、高频</strong>的定时场合，尤其适合用作<strong>串口通信的波特率发生器</strong>。</li><li><strong>初值计算</strong>：<code>初值 = 256 - N</code> (N为需要的计数值)<ul><li>例如，要定时200个机器周期，初值 &#x3D; 256 - 200 &#x3D; 56。所以 <code>THx = 56</code>, <code>TLx = 56</code>。</li></ul></li></ul><p><strong>模式 3 (M1&#x3D;1, M0&#x3D;1)：两个独立的8位定时器（仅适用于T0）</strong></p><ul><li><strong>工作原理</strong>：<ul><li>当T0设置为模式3时，它会被拆分成<strong>两个独立的8位计数器</strong>。</li><li><strong>TL0</strong>：占用原来T0的全部控制位（GATE, C&#x2F;T, TR0, TF0, INT0），可以工作在定时器或计数器模式。</li><li><strong>TH0</strong>：只能作为<strong>定时器</strong>使用（固定对机器周期计数），它占用了<strong>定时器1</strong>的 <strong>TR1</strong> 和 <strong>TF1</strong> 控制位。</li></ul></li><li><strong>特点</strong>：<ul><li>在这种模式下，<strong>定时器1</strong> 会因为TR1和TF1被占用而无法启动计数，但其<strong>串口波特率发生器功能仍然可以工作</strong>（通常设置T1为模式2，作为波特率发生器）。</li></ul></li><li><strong>适用场景</strong>：当系统需要<strong>三个定时器&#x2F;计数器</strong>时（例如，一个用于串口波特率，另外两个用于其他定时），可以让T0工作于模式3。</li></ul><hr><h3 id="如何使用-TMOD"><a href="#如何使用-TMOD" class="headerlink" title="如何使用 TMOD"></a>如何使用 TMOD</h3><p><strong>步骤一：选择模式并计算TMOD的值</strong></p><p>你需要分别设置定时器1和定时器0。</p><p><strong>示例1</strong>：设置定时器0为 <strong>模式1，定时器模式，不受外部引脚控制</strong>。</p><ul><li>GATE &#x3D; 0</li><li>C&#x2F;T &#x3D; 0 (定时器模式)</li><li>M1 &#x3D; 0, M0 &#x3D; 1 (模式1)</li><li>所以，定时器0的控制位为 <code>0001</code> (二进制)。</li><li>我们不关心定时器1，但为了不影响它，通常将其设为 <code>0000</code> (模式0，定时器模式)。</li><li>因此，整个TMOD寄存器应为 <code>0000 0001</code> (二进制) &#x3D; <code>0x01</code>。</li></ul><p><strong>示例2</strong>：设置定时器1为 <strong>模式2，定时器模式，用作波特率发生器</strong>。</p><ul><li>GATE &#x3D; 0</li><li>C&#x2F;T &#x3D; 0 (定时器模式)</li><li>M1 &#x3D; 1, M0 &#x3D; 0 (模式2)</li><li>所以，定时器1的控制位为 <code>0010</code> (二进制)。</li><li>定时器0设为 <code>0000</code>。</li><li>因此，整个TMOD寄存器应为 <code>0010 0000</code> (二进制) &#x3D; <code>0x20</code>。</li></ul><p><strong>步骤二：编写代码</strong></p><p><strong>直接赋值法（推荐，清晰）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置 T0 为模式1，定时器</span><br>TMOD = <span class="hljs-number">0x01</span>;<br><br><span class="hljs-comment">// 设置 T1 为模式2，定时器（不影响T0的设置）</span><br>TMOD = <span class="hljs-number">0x20</span>;<br></code></pre></td></tr></table></figure><p><strong>位操作法（更安全，避免影响另一个定时器）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 清除T0相关的位（低4位），然后设置为模式1</span><br>TMOD &amp;= <span class="hljs-number">0xF0</span>; <span class="hljs-comment">// 将低4位清零，高4位保持不变</span><br>TMOD |= <span class="hljs-number">0x01</span>; <span class="hljs-comment">// 设置低4位为0001（模式1）</span><br><br><span class="hljs-comment">// 清除T1相关的位（高4位），然后设置为模式2</span><br>TMOD &amp;= <span class="hljs-number">0x0F</span>; <span class="hljs-comment">// 将高4位清零，低4位保持不变</span><br>TMOD |= <span class="hljs-number">0x20</span>; <span class="hljs-comment">// 设置高4位为0010（模式2）</span><br></code></pre></td></tr></table></figure><p><strong>步骤三：赋予初值并启动定时器</strong></p><p>以定时器0模式1为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1. 设置模式</span><br>TMOD |= <span class="hljs-number">0x01</span>; <span class="hljs-comment">// 设置T0为模式1</span><br><br><span class="hljs-comment">// 2. 赋予初值（例如定时1ms，晶振12MHz）</span><br>TH0 = <span class="hljs-number">0xFC</span>;<br>TL0 = <span class="hljs-number">0x18</span>;<br><br><span class="hljs-comment">// 3. 开启总中断和定时器0中断</span><br>EA = <span class="hljs-number">1</span>;<br>ET0 = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 4. 启动定时器0</span><br>TR0 = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 5. 等待中断发生...</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 6. 在中断服务函数中重装初值（模式1必须手动重装）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer0_isr</span><span class="hljs-params">()</span> interrupt 1 &#123;<br>    TH0 = <span class="hljs-number">0xFC</span>; <span class="hljs-comment">// 必须手动重装</span><br>    TL0 = <span class="hljs-number">0x18</span>;<br>    <span class="hljs-comment">// ... 执行你的定时任务</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">模式</th><th align="left">位数</th><th align="left">特点</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left"><strong>模式0</strong></td><td align="left">13位</td><td align="left">兼容旧型号，已淘汰</td><td align="left">不推荐使用</td></tr><tr><td align="left"><strong>模式1</strong></td><td align="left">16位</td><td align="left"><strong>最常用</strong>，范围大，需手动重装</td><td align="left">精确长定时（如1ms）</td></tr><tr><td align="left"><strong>模式2</strong></td><td align="left">8位</td><td align="left"><strong>自动重装</strong>，精度高</td><td align="left">串口波特率发生器，精确短定时</td></tr><tr><td align="left"><strong>模式3</strong></td><td align="left">两个8位</td><td align="left">T0拆分成两个独立定时器</td><td align="left">需要额外定时器时</td></tr></tbody></table><h2 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a><strong>AT24C02</strong></h2><p><img src="https://live2d-api-jet.vercel.app/model/image/51/EEPROM.png" srcset="/img/loading.gif" lazyload alt="图示为普中51-实验板上的EEPROM"></p><ul><li>AT24C02是一种可以实现掉电不丢失的存储器，可以用于保存单片机运行时想要永久保存的数据信息</li><li>存储介质：<strong>EEPROM</strong></li><li>通讯接口：IIC总线</li><li>容量：256字节</li><li>引脚：VCC、GND、WE（写使能，上面有一横线表示低电平有效）、SCL和SDA（IIC接口）、（E0、E1、E2）（IIC地址）</li></ul><h3 id="IIC总线"><a href="#IIC总线" class="headerlink" title="IIC总线"></a><strong>IIC总线</strong></h3><ul><li><p><strong>I2C</strong>，全称 <strong>Inter-Integrated Circuit</strong>，中文常译为“集成电路总线”，是由飞利浦公司开发的一种简单、双向、同步、串行的通信总线。</p></li><li><p>两根通信线：<strong>SCL</strong>（Serial Clock）、<strong>SDA</strong>（Serial Data）</p></li><li><p>同步、半双工、带<strong>数据应答</strong></p></li><li><p>通用I2C总线，可以使各种设备的通信标准统一，对于厂家来说，使用成熟的方案可以缩短芯片的设计周期、提高稳定性，对于应用者来说，使用通用的通信协议可以避免学习各种各样的自定义协议，降低学习和应用的难度</p></li><li><p>I2C电路规范：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_CircuitSpecifications.png" srcset="/img/loading.gif" lazyload style="zoom:80%"><ul><li><p>所有I2C设备的SCL连在一起，SDA连在一起</p></li><li><p>设备的SCL和SDA均要配置成<strong>开漏输出</strong>模式</p></li><li><p>SCL和SDA各添加一个<strong>上拉电阻</strong>，阻值一般为4.7欧左右</p></li><li><p><strong>开漏输出</strong>和<strong>上拉电阻</strong>的共同作用是实现了**“线与”**的功能，此设计主要是为了解决多机通信互相干扰的问题</p></li><li><p><strong>“线与”</strong>：如果CPU想和其中的一个设备进行通信的话，最好的状态就是其它设备<strong>断开</strong>，而<strong>开漏模式</strong>中输出高电平的时候是处于<strong>高阻态</strong>，外面的<strong>上拉电阻</strong>是当所有设备都断开的时候，用来提供<strong>上拉能力</strong>的；由于SDA和SCL都是开漏输出，都需要<strong>上拉电阻</strong>才能产生高电平，所以任何的设备都可以将总线拉低，但<strong>不能主动驱动高电平</strong>，这就是“线与”的逻辑：<u><strong>任何设备都能拉低总线</strong></u></p></li><li><p><strong>释放SDA的本质</strong></p><ul><li>当<strong>所有设备都释放SDA</strong>（高阻态）时：SDA &#x3D; 高电平（由上拉电阻决定）</li><li>当<strong>任一设备拉低SDA</strong>时：SDA &#x3D; 低电平</li></ul><table><thead><tr><th align="left">场景</th><th align="left">释放SDA的目的</th><th align="left">不释放的后果</th></tr></thead><tbody><tr><td align="left"><strong>接收字节前</strong></td><td align="left">交出SDA控制权，让从机发送数据</td><td align="left">数据冲突，通信失败</td></tr><tr><td align="left"><strong>接收应答前</strong></td><td align="left">让从机能够拉低SDA发送ACK</td><td align="left">无法获得从机应答，通信中断</td></tr></tbody></table><p><strong>核心思想：</strong> I2C是<strong>半双工</strong>总线，SDA是<strong>共享资源</strong>。释放SDA就是”轮到你了”的信号，确保任何时候只有一方在驱动总线，避免冲突</p></li></ul></li></ul><h3 id="IIC时序结构"><a href="#IIC时序结构" class="headerlink" title="IIC时序结构"></a><strong>IIC时序结构</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_Condition.png" srcset="/img/loading.gif" lazyload alt="上位SDA，下位SCL" style="zoom:50%"><ul><li><strong>起始条件</strong>：SCL高电平期间，SDA从高电平切换到低电平</li><li><strong>终止条件</strong>：SCL高电平期间，SDA从低电平切换到高电平</li></ul><hr><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_Send.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>发送一个字节</strong>：SCL低电平期间，<strong>主机</strong>将数据为依次放到SDA线上（高位在前），然后拉高SCL，<strong>从机</strong>将在SCL高电平期间读取数据未，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程八次，即可发送一个字节</li></ul><hr><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_Read.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>接收一个字节</strong>：SCL低电平期间，从机将数据位依次放到SDA线上（高位在前），然后拉高SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据的变化，依次循环上述过程八次，既可以接收一个字节（主机在接收之前，需要释放SDA）</li></ul><hr><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_Answer.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>发送应答</strong>：在接收完一个字节之后，主机在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</li><li><strong>接收应答</strong>：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示分应答（主机在接收之前，需要释放SDA）</li></ul><h3 id="IIC数据帧"><a href="#IIC数据帧" class="headerlink" title="IIC数据帧"></a><strong>IIC数据帧</strong></h3><ul><li><p>发送一帧数据 完成任务（向谁发什么）</p><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_SendDataFrame.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><p>前七位是IIC的地址，其中地址的前四位是固定端，后三位是可配置的，最后一位是读写位</p></li></ul><hr><ul><li><p>接收一帧数据 完成任务（向谁收什么）</p><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_ReadDataFrame.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></li></ul><hr><ul><li><p>先发送再接收数据帧（复合格式）完成任务（向谁收指定的什么）</p><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_SendReadDataFrame.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></li></ul><hr><ul><li><p>字节写：在WOED ADDRESS处写入数据DATA</p><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_ByteWrite.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><hr></li><li><p>随机读：读出在WORD ADDRESS处的数据DATA</p><img src="https://live2d-api-jet.vercel.app/model/image/51/IIC_RandRead.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></li><li><p>AT24C02的固定地址位1010，可配置地址本开发板上是000，所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1</p></li></ul><h2 id="DS18B20"><a href="#DS18B20" class="headerlink" title="DS18B20"></a><strong>DS18B20</strong></h2><h3 id="DS18B20简介"><a href="#DS18B20简介" class="headerlink" title="DS18B20简介"></a><strong>DS18B20简介</strong></h3><p><strong><img src="https://live2d-api-jet.vercel.app/model/image/51/DS18B20.png" srcset="/img/loading.gif" lazyload alt="图示为普中51-实验板上的DS18B20"></strong></p><ul><li>DS18B20是一种常见的<strong>数字温度传感器</strong>，其控制命令和数据都是以<strong>数字信号</strong>的方式输入输出，相比较于<strong>模拟温度传感器</strong>，其具有功能强大、硬件简单、易扩展、抗干扰强等特点</li><li>测温范围：-55°C到+125°C</li><li>通信接口：1-Wire（<strong>单总线</strong>）</li><li>其他特征：可形成总线结构、内置温度报警功能、可<strong>寄生供电</strong>（要提供强上拉）</li><li>引脚：VDD、VCC、（I&#x2F;O）DQ（单总线接口）</li></ul><h3 id="内部结构框图"><a href="#内部结构框图" class="headerlink" title="内部结构框图"></a><strong>内部结构框图</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/DS18B20StructuralDiagram.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><p>PARASITE POWER CIRCUIT：寄生功率电路</p></li><li><p>POWER-SUPPLY SENSE：感应外部电源是否存在</p></li><li><p>64-BIT ROM：作为器件地址（<strong>全球唯一</strong>），用于总线通信的寻址</p></li><li><p>EEPROM：用于保存温度触发阈值和配置参数</p></li><li><p>8-BIT CRC CENERATOR：循环冗余校验</p></li><li><p>SCRATCHPAD：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/DS18B20MemoryStructure.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>第0位和第1位分别存的是Temperature的最低有效字节和最高有效字节，默认是0x0550（85°C)</li><li>第2、3、4位用于和EEPROM进行交换的</li><li>第5、6、7位作为保留位</li><li>第8位校验位</li></ul></li></ul><h3 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a><strong>单总线</strong></h3><ul><li><p>单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线</p></li><li><p>一根通信线：DQ</p></li><li><p>异步、<strong>半双工</strong></p></li><li><p>单总线只需要一根通信线即可实现数据的双向传输，当采用<strong>寄生供电</strong>时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线</p></li><li><p>单总线需要<strong>最高的优先级</strong>，因为它里面有严格的延迟时间，如果被<strong>中断器中断</strong>的话就会导致数据传输出错</p></li><li><p>单总线电路规范：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_CircuitSpecifications.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>设备的DQ均需要配置成<strong>开漏输出模式</strong></li><li>DQ添加一个<strong>上拉电阻</strong>，阻值一般为4.7千欧左右</li><li>若此总线的丛机采用寄生供电，则主机还应配一个<strong>强上拉输出电路</strong></li></ul></li></ul><h3 id="单总线时序结构"><a href="#单总线时序结构" class="headerlink" title="单总线时序结构"></a><strong>单总线时序结构</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_Init.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><p><strong>初始化</strong>：主机将总线拉低至少480us，然后释放总线，等待15<del>60us（不好取的时候，使用中间值）后，存在的从机会拉低60</del>240us以响应主机，之后从机释放总线，这里面的时间是绝对是时间，因为只有一根线没法传递时间，所以必须要使用<strong>绝对时间</strong></p><ul><li><p>Bus master pulling low：主机拉低总线</p></li><li><p>DS18B20 pulling low：从机拉低总线</p></li><li><p>Resistor pullup：电阻上拉，由于表示的是<strong>弱上拉</strong>，所以线是弯的</p></li></ul></li></ul><hr><img src="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_SendBit.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><p><strong>发送一位</strong>：主机将总线拉低60<del>120us，然后释放总线，表示发送0；主机将总线拉低1</del>15us，然后释放总线，表示发送1。从机将在总线拉低30us后（典型值）读取电平，整个时间应大于60us</p></li><li><p>Trec：发送或接送的时间隔应大于1us</p></li><li><p>图中的阴影部分表示可以释放总线的范围</p></li></ul><hr><img src="https://live2d-api-jet.vercel.app/model/image/51/SingleBus_ReceiveBit.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>接送一位</strong>：主机将总线拉低1~15us，然后释放总线，并拉低后15us内读取总线电平（尽量接近15us的末尾），读取为低电平则为接收0，读取为高电平则为接收1，整个时间片应大于60us<ul><li>主机拉低总线释放后，如果从机没有拉低，那么就会弹上去，如果从机拉低了，那么会后弹上去</li></ul></li></ul><hr><ul><li><p><strong>发送一个字节</strong>：连续调用8次发送一位的时序，依次发送一个字节的8位（低位在前）</p></li><li><p><strong>接收一个字节</strong>：连续调用8次接收一位的时序，依次接收一个字节的8位（低位在前）</p></li></ul><h3 id="DS18B20操作流程"><a href="#DS18B20操作流程" class="headerlink" title="DS18B20操作流程"></a><strong>DS18B20操作流程</strong></h3><ul><li><p><strong>初始化</strong>：从机复位，主机判断从机是否响应</p></li><li><p><strong>ROM操作</strong>：ROM指令+本指令需要的读写操作</p></li><li><p><strong>功能操作</strong>：功能指令+本指令需要的读写操作</p></li><li><p><strong>ROM指令</strong>：</p><table><thead><tr><th align="left">指令名称</th><th align="left">指令代码</th><th align="left">适用系统</th><th align="center">主要功能</th></tr></thead><tbody><tr><td align="left"><strong>Search ROM</strong></td><td align="left">F0h</td><td align="left">多点</td><td align="center">发现总线上所有设备的ROM码</td></tr><tr><td align="left"><strong>Read ROM</strong></td><td align="left">33h</td><td align="left"><strong>单点</strong></td><td align="center">读取单一设备的ROM码</td></tr><tr><td align="left"><strong>Match ROM</strong></td><td align="left">55h</td><td align="left">多点</td><td align="center"><strong>精确寻址</strong>一个已知ROM码的设备</td></tr><tr><td align="left"><strong>Skip ROM</strong></td><td align="left">CCh</td><td align="left">单点&#x2F;广播</td><td align="center">跳过寻址，用于<strong>单点操作</strong>或广播命令</td></tr><tr><td align="left"><strong>Alarm Search</strong></td><td align="left">ECh</td><td align="left">多点</td><td align="center">只搜索触发温度报警的设备</td></tr><tr><td align="left"><strong>Overdrive Skip ROM</strong></td><td align="left">3Ch</td><td align="left">单点（超速）</td><td align="center">在超速模式下跳过ROM</td></tr><tr><td align="left"><strong>Overdrive Match ROM</strong></td><td align="left">69h</td><td align="left">多点（超速）</td><td align="center">在超速模式下匹配ROM</td></tr></tbody></table></li><li><p><strong>功能指令</strong>：</p><table><thead><tr><th align="left">指令名称</th><th align="left">指令代码</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">CONVERT T</td><td align="left">44h</td><td align="left"><strong>启动温度转换</strong>。转换完成后，温度值存储在暂存器中。</td></tr><tr><td align="left">WRITE SCRATCHPAD</td><td align="left">4Eh</td><td align="left">向DS18B20的暂存器写入数据，通常用于写入TH和TL报警阈值以及配置寄存器。</td></tr><tr><td align="left">READ SCRATCHPAD</td><td align="left">BEh</td><td align="left"><strong>读取暂存器</strong>的内容，包括温度值、TH、TL和配置寄存器等共9个字节。</td></tr><tr><td align="left">COPY SCRATCHPAD</td><td align="left">48h</td><td align="left">将暂存器中的TH、TL和配置寄存器复制到DS18B20的E2PROM中，用于永久存储。</td></tr><tr><td align="left">RECALL E2</td><td align="left">B8h</td><td align="left">将E2PROM中存储的TH、TL和配置寄存器值召回至暂存器中。</td></tr><tr><td align="left">READ POWER SUPPLY</td><td align="left">B4h</td><td align="left">读取DS18B20的<strong>供电模式</strong>：0为寄生电源，1为外部电源。</td></tr></tbody></table></li></ul><h3 id="DS18B20数据帧"><a href="#DS18B20数据帧" class="headerlink" title="DS18B20数据帧"></a><strong>DS18B20数据帧</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/DS18B20_ConvertTemperture.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>温度变换</strong>：初始化-&gt;跳过ROM-&gt;开始温度变换</li></ul><hr><img src="https://live2d-api-jet.vercel.app/model/image/51/DS18B20_ReadTemperature.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>温度读取</strong>：初始化-&gt;跳过ROM-&gt;都暂存器-&gt;连续的读操作</li></ul><h3 id="温度存储格式"><a href="#温度存储格式" class="headerlink" title="温度存储格式"></a><strong>温度存储格式</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/Temperature_MemoryStructure.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>其中第0位到第3位存储的是小数部分，第11位到第15位存储的是符号位，以<strong>补码</strong>的形式存储</li></ul><img src="https://live2d-api-jet.vercel.app/model/image/51/Temperature_MemoryStructure2.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><h2 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a><strong>LCD1602</strong></h2><h3 id="LCD1602介绍"><a href="#LCD1602介绍" class="headerlink" title="LCD1602介绍"></a>LCD1602介绍</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/LCD1602.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><p>LCD1602（Liquid Crystal Display）液晶显示屏是<strong>字符型液晶显示模块</strong>，可以显示ASCII码的标准字符和其它的一些内置特殊字符，还可以有8个自定义字符</p></li><li><p>显示容量：16×2个字符，每个字符为5×7点阵</p></li><li><p>引脚：VSS（地）、VDD（电源正极4.5<del>5.5V）、VO（对比度调节电压）、<strong>RS</strong>（数据&#x2F;指令选择，1为数据，0为指令）、<strong>RW</strong>（读&#x2F;写选择，1为读，0为写）、<strong>E</strong>（使能，1为数据有效，下降沿执行命令）、D0</del>D7（数据输入&#x2F;输出）、A（背光灯电源正极）、K（背光灯电源负极）</p></li></ul><h3 id="内部结构框图-1"><a href="#内部结构框图-1" class="headerlink" title="内部结构框图"></a><strong>内部结构框图</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_Structure.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><hr><ul><li>DDRAM（数据显示区）</li></ul><img src="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_DDRAM.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><hr><ul><li>CGRAM+CGROM（字模库）</li></ul><img src="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_CGRAM_CGROM.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>CDRAM区我们可以自定义字符写在里面</li></ul><h3 id="时序结构"><a href="#时序结构" class="headerlink" title="时序结构"></a>时序结构</h3><ul><li><p>写数据&#x2F;指令</p><img src="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_TemporalStructure.png" srcset="/img/loading.gif" lazyload style="zoom:50%"></li></ul><h3 id="LCD1602指令集"><a href="#LCD1602指令集" class="headerlink" title="LCD1602指令集"></a>LCD1602指令集</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/LCD1602_InstructionSet.png" srcset="/img/loading.gif" lazyload><h3 id="LCD1602操作流程"><a href="#LCD1602操作流程" class="headerlink" title="LCD1602操作流程"></a>LCD1602操作流程</h3><ul><li><p>初始化：</p><p>发送指令0x38 &#x2F;&#x2F;八位数据接口，两行显示，5×7点阵</p><p>发送指令0x0c &#x2F;&#x2F;显示开，光标关，闪烁光</p><p>发送指令0x06 &#x2F;&#x2F;数据读写操作后，光标自动加一，画面不动</p><p>发送指令0x01 &#x2F;&#x2F;清屏</p></li><li><p>显示字符：</p><p>发送指令0x80|AC &#x2F;&#x2F;设置光标位置</p><p>发送数据 &#x2F;&#x2F;发送要显示的字符数据</p><p>发送数据 &#x2F;&#x2F;发送要显示的字符数据</p><p>。。。</p></li></ul><h3 id="字符、字符串"><a href="#字符、字符串" class="headerlink" title="字符、字符串"></a>字符、字符串</h3><ul><li><p><strong>字符</strong>：根据一定规则建立的数字到字符的映射（ASCII码表）</p><p>例如：0x21&#x3D;‘!’，0x41&#x3D;‘A’，0x00&#x3D;‘\0’</p><p>定义方法：char x&#x3D;’A’；等效于char x&#x3D;0x41；</p></li><li><p><strong>字符数组</strong>：存储字符变量非一个数组</p><p>定义方法：char y[]&#x3D;{‘A’,’B’,’C’}；等效于char y[]&#x3D;{0x41,0x42,0x43}；</p></li><li><p><strong>字符串</strong>：在字符数组后加一个字符串结束标志，本质上是字符数组</p><p>定义方法：char z[]&#x3D;”ABC”；等效于char z[]&#x3D;{‘A’,’B’,’C’,’\0’}；</p></li></ul><h2 id="直流电机驱动（PWM）"><a href="#直流电机驱动（PWM）" class="headerlink" title="直流电机驱动（PWM）"></a>直流电机驱动（PWM）</h2><h3 id="直流电机介绍"><a href="#直流电机介绍" class="headerlink" title="直流电机介绍"></a>直流电机介绍</h3><ul><li>直流电机是一种将电能转换为机械能的装置。一般的直流电机有两个电极，电极正接正转，反接反转</li><li>直流电机主要由永磁体（定子）、线圈（转子）、和换向器组成</li><li>除直流电机外，常见的电机还有步进电机、舵机、无刷电机、空心杯电机等</li></ul><h3 id="电机驱动电路"><a href="#电机驱动电路" class="headerlink" title="电机驱动电路"></a>电机驱动电路</h3><ul><li><p>大功率器件直接驱动</p><img src="https://live2d-api-jet.vercel.app/model/image/51/Motor_DirectDrive.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><p>直接驱动只能朝一个方转</p></li><li><p>每个电机都会有一个电感值，这是电机的固有属性，这个电感值对整个驱动系统的性能有着至关重要的影响，至于为什么会产生电感，是因为电流会产生磁场，而变化的磁场会产生感应电动势，从而产生反向的感应电压，电流变化的越快，感应电动势越大，产生的反向的感应电压越大。电感值越大对，对电流变化的“抵抗”越强，产生的反向的感应电压可能会白mos管击穿。ULN2003中也有续流二极管</p></li><li><table><thead><tr><th align="left">组件&#x2F;参数</th><th align="left">主要作用与影响</th></tr></thead><tbody><tr><td align="left"><strong>续流二极管</strong></td><td align="left"><strong>保护神</strong>。在开关关断时，为电机电感提供能量释放回路，钳制高压尖峰，防止开关管击穿。</td></tr><tr><td align="left"><strong>电机电感值</strong></td><td align="left"><strong>双刃剑</strong>。<strong>大电感</strong>意味着<strong>平滑的电流、低纹波、运行平稳</strong>，但<strong>动态响应慢</strong>；<strong>小电感</strong>意味着<strong>快速的电流响应、高动态性能</strong>，但<strong>电流纹波大、发热和噪音问题更突出</strong>。</td></tr></tbody></table></li></ul></li><li><p>H桥驱动</p><img src="https://live2d-api-jet.vercel.app/model/image/51/Motor_H-BridgeDrive.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>由于H桥驱动电路中没有续流二极管，所以对于mos要求要有很高的耐压特性，防止容易被击穿</li></ul></li></ul><h3 id="PWM介绍"><a href="#PWM介绍" class="headerlink" title="PWM介绍"></a>PWM介绍</h3><ul><li><p>PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效的获取所需要的模拟参数，常应用于电机控速、开关电源等领域</p></li><li><p>PWM重要参数：</p><p>频率&#x3D;1&#x2F;Ts 占空比&#x3D;Ton&#x2F;Ts 精度&#x3D;占空比变化步距</p></li></ul><h3 id="产生PWM的方法"><a href="#产生PWM的方法" class="headerlink" title="产生PWM的方法"></a>产生PWM的方法</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/PWM_Generate.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><h2 id="AD-DA"><a href="#AD-DA" class="headerlink" title="AD&#x2F;DA"></a>AD&#x2F;DA</h2><h3 id="AD-DA介绍"><a href="#AD-DA介绍" class="headerlink" title="AD&#x2F;DA介绍"></a>AD&#x2F;DA介绍</h3><ul><li>AD（Analog to Digital）：模拟-数字转换，将模拟信号转换为计算机可以操作的数字信号</li><li>DA（Digital to Analog）：数字-模拟转换，将计算机输出的数字信号转换为模拟信号</li><li>AD&#x2F;DA转换打开了计算机于模拟信号的大门，极大的提高了计算机系统的应用范围，也为模拟信号数字化处理提供了可能</li></ul><h3 id="硬件电路模型"><a href="#硬件电路模型" class="headerlink" title="硬件电路模型"></a>硬件电路模型</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/ADDA_HardwareCircuitModel.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>AD转换通常有多个输入通道，用多路选择开关连接至AD转换器，以实现AD多路复用的目的，提高硬件利用率</li><li>AD&#x2F;DA于单片机数据传送可使用并口（速度快，原理简单），也可以使用串口（接线少，使用方便）</li><li>可将AD&#x2F;DA模块直接集成在单片机内，这样直接写入&#x2F;读出寄存器就可进行AD&#x2F;DA转换，单片机的I&#x2F;O口可直接复用为AD&#x2F;DA的通道</li></ul><h3 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h3><p>推荐去看ADC0809和DAC0832</p><img src="https://live2d-api-jet.vercel.app/model/image/51/ADDA_HardwardCircuit.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><h3 id="运算放大器"><a href="#运算放大器" class="headerlink" title="运算放大器"></a>运算放大器</h3><ul><li>运算放大器（简称“运放”）是具有很高放大倍数的放大电路单元，内部集成了差分放大器、电压放大器、功率放大器三级放大电路，是一个性能完备、功能强大的通用放大电路单元，由于其应用十分广泛，现已作为基本的电路元件出现在电路图中</li><li>运算放大器可以构成的电路有：电压比较器、反向放大器、同向放大器、电压跟随器、加法器、积分器、微分器等</li><li>运算放大器电路的分析方法：虚短、续断（负反馈条件下）</li></ul><img src="https://live2d-api-jet.vercel.app/model/image/51/OperationalAmplifier.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><h3 id="运放电路"><a href="#运放电路" class="headerlink" title="运放电路"></a>运放电路</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/OpAmpCircuit.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><table><thead><tr><th align="left">特性</th><th align="left"><strong>电压比较器</strong></th><th align="left"><strong>反向放大器</strong></th></tr></thead><tbody><tr><td align="left"><strong>核心功能</strong></td><td align="left"><strong>比较、判断</strong></td><td align="left"><strong>放大、缩放</strong></td></tr><tr><td align="left"><strong>工作区域</strong></td><td align="left"><strong>非线性区（饱和区）</strong></td><td align="left"><strong>线性区</strong></td></tr><tr><td align="left"><strong>反馈类型</strong></td><td align="left"><strong>开环</strong> 或 <strong>正反馈</strong></td><td align="left"><strong>深度负反馈</strong></td></tr><tr><td align="left"><strong>输出状态</strong></td><td align="left"><strong>二值化</strong>（高&#x2F;低电平）</td><td align="left"><strong>连续变化的模拟电压</strong></td></tr><tr><td align="left"><strong>核心关系</strong></td><td align="left"><code>if (Vin &gt; Vref) Vout=HIGH; else Vout=LOW;</code></td><td align="left"><strong><code>Vout = - (Rf / R1) \* Vin</code></strong></td></tr><tr><td align="left"><strong>“虚短”成立？</strong></td><td align="left"><strong>不成立</strong>（两端电压差很大）</td><td align="left"><strong>成立</strong>（是电路分析的基础）</td></tr><tr><td align="left"><strong>“虚地”存在？</strong></td><td align="left"><strong>不存在</strong></td><td align="left"><strong>存在</strong>（当同相端接地时）</td></tr><tr><td align="left"><strong>输入阻抗</strong></td><td align="left">非常高</td><td align="left">较低（约等于 <code>R1</code>）</td></tr><tr><td align="left"><strong>典型应用</strong></td><td align="left">过零检测、方波发生器、电平检测</td><td align="left">信号放大、有源滤波、加法电路</td></tr></tbody></table><p><strong>简单记忆</strong>：</p><ul><li><strong>比较器</strong>像一个<strong>裁判</strong>，只关心谁大谁小，输出非黑即白。</li><li><strong>反向放大器</strong>像一个<strong>可调的光学镜片</strong>，能按比例缩小或放大信号，并使其上下颠倒（反向）。</li></ul><img src="https://live2d-api-jet.vercel.app/model/image/51/OpAmpCircuit2.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><table><thead><tr><th align="left">特性</th><th align="left"><strong>同向放大器</strong></th><th align="left"><strong>电压跟随器</strong></th></tr></thead><tbody><tr><td align="left"><strong>核心功能</strong></td><td align="left"><strong>放大、缩放</strong></td><td align="left"><strong>缓冲、隔离、阻抗变换</strong></td></tr><tr><td align="left"><strong>工作区域</strong></td><td align="left"><strong>线性区</strong></td><td align="left"><strong>线性区</strong></td></tr><tr><td align="left"><strong>反馈类型</strong></td><td align="left"><strong>深度电压串联负反馈</strong></td><td align="left"><strong>深度电压串联负反馈（100%反馈）</strong></td></tr><tr><td align="left"><strong>输出状态</strong></td><td align="left"><strong>连续变化的模拟电压</strong></td><td align="left"><strong>连续变化的模拟电压</strong></td></tr><tr><td align="left"><strong>核心关系</strong></td><td align="left"><strong><code>Vout = (1 + Rf/R1) \* Vin</code></strong></td><td align="left"><strong><code>Vout = Vin</code></strong></td></tr><tr><td align="left"><strong>“虚短”成立？</strong></td><td align="left"><strong>成立</strong>（是电路分析的基础）</td><td align="left"><strong>成立</strong>（是电路分析的基础）</td></tr><tr><td align="left"><strong>“虚地”存在？</strong></td><td align="left"><strong>不存在</strong></td><td align="left"><strong>不存在</strong></td></tr><tr><td align="left"><strong>输入阻抗</strong></td><td align="left"><strong>非常高</strong></td><td align="left"><strong>极高</strong></td></tr><tr><td align="left"><strong>典型应用</strong></td><td align="left">高输入阻抗放大电路、仪表放大器、信号调理</td><td align="left">缓冲器、阻抗匹配、信号隔离、驱动容性负载</td></tr></tbody></table><ul><li><strong>需要放大信号且不关心相位</strong>：优先选择<strong>同向放大器</strong>（输入阻抗高）</li><li><strong>需要放大信号且要反相</strong>：选择<strong>反向放大器</strong></li><li><strong>只需要传递信号而不需要放大</strong>：选择<strong>电压跟随器</strong>（阻抗匹配）</li><li><strong>需要判断信号大小</strong>：选择<strong>电压比较器</strong></li></ul><h3 id="DA原理"><a href="#DA原理" class="headerlink" title="DA原理"></a>DA原理</h3><ul><li><p>T型电阻网络DA转换器：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/DA_TConverter.png" srcset="/img/loading.gif" lazyload style="zoom:50%"> <img src="https://live2d-api-jet.vercel.app/model/image/51/DA_TFormula.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>优点：输出稳定；坏处：占用IO口，精度不可变</li></ul></li><li><p>PWM型DA转换器：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/DA_PWMConverter.png" srcset="/img/loading.gif" lazyload style="zoom:50%"> <img src="https://live2d-api-jet.vercel.app/model/image/51/DA_PWMFormula.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>优点：比较节省IO口，可以提高精度；坏处：占用单片机资源，可能会有文波</li></ul></li></ul><h3 id="AD原理"><a href="#AD原理" class="headerlink" title="AD原理"></a>AD原理</h3><ul><li><p>逐次逼近型AD转换器：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/AD_SuccessivelyConverter.png" srcset="/img/loading.gif" lazyload style="zoom:50%"> <img src="https://live2d-api-jet.vercel.app/model/image/51/AD_SuccessivelyFormula.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>原理是二分查找</li></ul></li></ul><h3 id="AD-DA的性能指标"><a href="#AD-DA的性能指标" class="headerlink" title="AD&#x2F;DA的性能指标"></a>AD&#x2F;DA的性能指标</h3><ul><li><strong>分辨率</strong>：指AD&#x2F;DA数字量的精细程度，通常用位数表示。例如，对于5V电源系统来说，8位的AD可将5V等分为256份，即数字量变化最小一个单位时，模拟量变化5V&#x2F;256&#x3D;0.01953125V，所以，8位AD的电压分辨率为0.01953125V，AD&#x2F;DA的位数越高，分辨率就越高</li><li><strong>转换速度</strong>：表示AD&#x2F;DA的最大采样&#x2F;建立频率，通常用转换频率或者转换时间来表示，对于采样&#x2F;输出高速信号，应注意AD&#x2F;DA的转换速度</li></ul><h3 id="XPT2046"><a href="#XPT2046" class="headerlink" title="XPT2046"></a>XPT2046</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/XTP2046.png" srcset="/img/loading.gif" lazyload><h3 id="XPT2046时序"><a href="#XPT2046时序" class="headerlink" title="XPT2046时序"></a>XPT2046时序</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/XPT2046Time.png" srcset="/img/loading.gif" lazyload><ul><li><strong>DIN</strong>：串行数据输入，从MCU到XPT2046</li><li><strong>DOUT</strong>：串行数据输出，从XPT2046到MCU</li><li><strong>DCLK</strong>：串行时钟，由MCU产生</li><li><strong>CS</strong>：片选信号，低电平有效</li></ul><h3 id="XPT2046控制位命令"><a href="#XPT2046控制位命令" class="headerlink" title="XPT2046控制位命令"></a>XPT2046控制位命令</h3><p><strong>控制字节格式</strong>（8位）</p><table><thead><tr><th align="left">位</th><th align="left">名称</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">START</td><td align="left">起始位。为一表示一个新的控制字节到来，为0则忽略PIN引脚上数据</td></tr><tr><td align="left">6-4</td><td align="left">A2&#x2F;A1&#x2F;A0</td><td align="left">通道选择位。</td></tr><tr><td align="left">3</td><td align="left">MODE</td><td align="left">转换精度（分辨率）：0&#x3D;12位，1&#x3D;8位</td></tr><tr><td align="left">2</td><td align="left">SER&#x2F;DFR</td><td align="left">单端输入方式&#x2F;差分输入方式选择位。为1是单端输入方式，为0是差分输入方式</td></tr><tr><td align="left">1-0</td><td align="left">PD1&#x2F;PD0</td><td align="left">低功率模式选择位。若为11，器件总处于供电状态；若为00，器件在变换之间处于低功率</td></tr></tbody></table><p><strong>通道选择</strong>（A2&#x2F;A1&#x2F;A0）</p><table><thead><tr><th align="left">A2</th><th align="left">A1</th><th align="left">A0</th><th align="left">通道</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">Y+ 位置测量</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">X+ 位置测量</td></tr><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">Y- 驱动</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">X- 驱动</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">电池电压监测</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">温度监测</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">AUX输入</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">0</td><td align="left">内部参考电压</td></tr></tbody></table><h2 id="红外遥控"><a href="#红外遥控" class="headerlink" title="红外遥控"></a>红外遥控</h2><h3 id="红外遥控器简介"><a href="#红外遥控器简介" class="headerlink" title="红外遥控器简介"></a>红外遥控器简介</h3><ul><li>红外遥控器是利用红外光进行通信的设备，由红外LED将调制后的信号发出，由专门的红外接送头进行解调输出</li><li>通信方式：单工、异步</li><li>红外LED波长：940nm</li><li>通信协议标准：NEC标准</li></ul><h3 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/RedLED_HardwareCircuit.png" srcset="/img/loading.gif" lazyload style="zoom:80%"><ul><li>其中左边的为发送电路，而右边的为接收电路</li><li>其中发送电路接入38KHZ信号的目的是为了调制，因为自然界也有红外光，而为了区分需要进行调制，如果不接入38KHZ的信号，就必须在输入IN前对它进行调制</li><li>接收电路的作用，是用来虑波，由于信号发送的很快（几十ms），所以不能用for循环来判断，为了更快的处理，要把OUT引脚接到外部中断引脚上</li></ul><h3 id="基本发送于接收"><a href="#基本发送于接收" class="headerlink" title="基本发送于接收"></a>基本发送于接收</h3><ul><li>空闲状态：红外LED不亮，接收头输出高电平</li><li>发送低电平：红外LED以38KHZ频率闪烁发光，接收头输出低电平</li><li>发送高电平：红外LED不亮，接送头输出高电平</li></ul><img src="https://live2d-api-jet.vercel.app/model/image/51/RedLED_SeedAndReceive.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><h3 id="NEC编码"><a href="#NEC编码" class="headerlink" title="NEC编码"></a>NEC编码</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/NEC_Code.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>传送的数据中的地址反码和命令反码用于验证</li></ul><h3 id="外部中断-1"><a href="#外部中断-1" class="headerlink" title="外部中断"></a>外部中断</h3><ul><li><p>STC89C52有4个外部中断（引脚p3.2和p3.3）</p></li><li><p>STC89C52的外部中断分为两种触发方式：下降沿触发和低电平触发</p></li><li><p>中断号：</p><img src="https://live2d-api-jet.vercel.app/model/image/51/Interrupt_Sign.png" srcset="/img/loading.gif" lazyload></li></ul><h3 id="遥控器键码值"><a href="#遥控器键码值" class="headerlink" title="遥控器键码值"></a>遥控器键码值</h3><img src="https://live2d-api-jet.vercel.app/model/image/51/RedLED_Key.png" srcset="/img/loading.gif" lazyload style="zoom:67%"><h2 id="DS1302"><a href="#DS1302" class="headerlink" title="DS1302"></a><strong>DS1302</strong></h2><h3 id="DS1302简介"><a href="#DS1302简介" class="headerlink" title="DS1302简介"></a><strong>DS1302简介</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/DS1302_Introduction.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>DS1302 涓流充电计时芯片包含一个实时时钟&#x2F;日历和31 字节的静态 RAM.通过简单的串行接口与微处理器通讯.这个实时时钟&#x2F;日历提供年月日,时分秒信息.对于少于31天的月份月末会自动调整,还有闰年校正.由于有一个AM&#x2F;PM指示器，时钟可以工作在12小时制或者24小时制</li><li>同步、半双工</li><li>引脚：CE（读写使能）、I&#x2F;O（数据线）、SCLK（串行时钟）、X1和X2（与标准的32.786kHz石英体连接、VCC1（备用电源）、VCC2（主电源）</li></ul><h3 id="命令字"><a href="#命令字" class="headerlink" title="命令字"></a><strong>命令字</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/DS1302_CommandWord.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li>命令字启动每一次数据传输，MSB（位7必须是逻辑1，如果是0，则禁止对DS1302写入，位6 在逻辑0时规定为时钟&#x2F;日历数据，逻辑1时为RAM数据；位 1 至 位 5 表示了输入输出的指定寄存器，LSB (位 0) 在逻辑0时为写操作(输出)，逻辑1时为读操作(输入)，命令字以LSB (位 0)开始总是输入.</li></ul><h3 id="寄存器地址定义"><a href="#寄存器地址定义" class="headerlink" title="寄存器地址定义"></a><strong>寄存器地址定义</strong></h3><img src="https://live2d-api-jet.vercel.app/model/image/51/DS1302_RegisterAddress.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><ul><li><strong>秒寄存器的位7 (CH)</strong>：<strong>时钟停止位</strong>。<ul><li><code>1</code>： 时钟振荡器<strong>停止</strong>，DS1302进入低功耗模式，此时可以初始化时间。</li><li><code>0</code>： 时钟<strong>启动</strong>，开始计时。</li><li><strong>重要</strong>：初始化时间时，通常先<code>CH=1</code>停止时钟，写完时间后再<code>CH=0</code>启动时钟。</li></ul></li><li><strong>小时寄存器的位7 (12&#x2F;24)</strong>：<ul><li><code>1</code>： 12小时制。</li><li><code>0</code>： 24小时制。</li></ul></li><li><strong>写保护寄存器的位7 (WP)</strong>：<ul><li><code>0</code>： <strong>允许</strong>写入时钟&#x2F;日历寄存器或RAM。</li><li><code>1</code>： <strong>禁止</strong>写入（写保护）。在初始化时间前，必须先将其清零。</li></ul></li><li><strong>涓流充电寄存器</strong>：用于配置是否对备用电池充电以及充电参数（如串联电阻和二极管数量）。</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Embedded/" class="category-chain-item">Embedded</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>51</div><div>https://indexqwq.github.io/2025/10/26/51/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>index</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年10月26日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/10/26/Linux/" title="Linux"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="/live2d-widget/dist/autoload.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>
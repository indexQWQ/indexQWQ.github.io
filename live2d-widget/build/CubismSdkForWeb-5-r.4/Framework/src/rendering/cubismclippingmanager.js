import{Constant}from"../live2dcubismframework";import{csmVector}from"../type/csmvector";import{csmRect}from"../type/csmrectf";import{CubismMatrix44}from"../math/cubismmatrix44";import{CubismTextureColor}from"./cubismrenderer";import{CubismLogError,CubismLogWarning}from"../utils/cubismdebug";let ColorChannelCount=4,ClippingMaskMaxCountOnDefault=36,ClippingMaskMaxCountOnMultiRenderTexture=32;class CubismClippingManager{constructor(t){this._renderTextureCount=0,this._clippingMaskBufferSize=256,this._clippingContextListForMask=new csmVector,this._clippingContextListForDraw=new csmVector,this._channelColors=new csmVector,this._tmpBoundsOnModel=new csmRect,this._tmpMatrix=new CubismMatrix44,this._tmpMatrixForMask=new CubismMatrix44,this._tmpMatrixForDraw=new CubismMatrix44,this._clippingContexttConstructor=t;let e=new CubismTextureColor;e.r=1,e.g=0,e.b=0,e.a=0,this._channelColors.pushBack(e),(e=new CubismTextureColor).r=0,e.g=1,e.b=0,e.a=0,this._channelColors.pushBack(e),(e=new CubismTextureColor).r=0,e.g=0,e.b=1,e.a=0,this._channelColors.pushBack(e),(e=new CubismTextureColor).r=0,e.g=0,e.b=0,e.a=1,this._channelColors.pushBack(e)}release(){for(let t=0;t<this._clippingContextListForMask.getSize();t++)this._clippingContextListForMask.at(t)&&(this._clippingContextListForMask.at(t).release(),this._clippingContextListForMask.set(t,void 0)),this._clippingContextListForMask.set(t,null);this._clippingContextListForMask=null;for(let t=0;t<this._clippingContextListForDraw.getSize();t++)this._clippingContextListForDraw.set(t,null);this._clippingContextListForDraw=null;for(let t=0;t<this._channelColors.getSize();t++)this._channelColors.set(t,null);(this._channelColors=null)!=this._clearedFrameBufferFlags&&this._clearedFrameBufferFlags.clear(),this._clearedFrameBufferFlags=null}initialize(i,t){t%1!=0&&(CubismLogWarning("The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer."),t=~~t),t<1&&CubismLogWarning("The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1."),this._renderTextureCount=t<1?1:t,this._clearedFrameBufferFlags=new csmVector(this._renderTextureCount);for(let e=0;e<i.getDrawableCount();e++)if(i.getDrawableMaskCounts()[e]<=0)this._clippingContextListForDraw.pushBack(null);else{let t=this.findSameClip(i.getDrawableMasks()[e],i.getDrawableMaskCounts()[e]);null==t&&(t=new this._clippingContexttConstructor(this,i.getDrawableMasks()[e],i.getDrawableMaskCounts()[e]),this._clippingContextListForMask.pushBack(t)),t.addClippedDrawable(e),this._clippingContextListForDraw.pushBack(t)}}findSameClip(i,e){for(let t=0;t<this._clippingContextListForMask.getSize();t++){var r=this._clippingContextListForMask.at(t),s=r._clippingIdCount;if(s==e){let e=0;for(let t=0;t<s;t++){var n=r._clippingIdList[t];for(let t=0;t<s;t++)if(i[t]==n){e++;break}}if(e==s)return r}}return null}setupMatrixForHighPrecision(r,s){let e=0;for(let t=0;t<this._clippingContextListForMask.getSize();t++){var i=this._clippingContextListForMask.at(t);this.calcClippedDrawTotalBounds(r,i),i._isUsing&&e++}if(0<e){if(this.setupLayoutBounds(0),this._clearedFrameBufferFlags.getSize()!=this._renderTextureCount){this._clearedFrameBufferFlags.clear();for(let t=0;t<this._renderTextureCount;t++)this._clearedFrameBufferFlags.pushBack(!1)}else for(let t=0;t<this._renderTextureCount;t++)this._clearedFrameBufferFlags.set(t,!1);for(let i=0;i<this._clippingContextListForMask.getSize();i++){var n=this._clippingContextListForMask.at(i),a=n._allClippedDrawRect,o=n._layoutBounds;let t=0,e=0;var l=r.getPixelsPerUnit(),u=n.getClippingManager().getClippingMaskBufferSize(),p=o.width*u,u=o.height*u;this._tmpBoundsOnModel.setRect(a),t=this._tmpBoundsOnModel.width*l>p?(this._tmpBoundsOnModel.expand(.05*a.width,0),o.width/this._tmpBoundsOnModel.width):l/p,e=this._tmpBoundsOnModel.height*l>u?(this._tmpBoundsOnModel.expand(0,.05*a.height),o.height/this._tmpBoundsOnModel.height):l/u,this.createMatrixForMask(s,o,t,e),n._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray()),n._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray())}}}createMatrixForMask(t,e,i,r){this._tmpMatrix.loadIdentity(),this._tmpMatrix.translateRelative(-1,-1),this._tmpMatrix.scaleRelative(2,2),this._tmpMatrix.translateRelative(e.x,e.y),this._tmpMatrix.scaleRelative(i,r),this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x,-this._tmpBoundsOnModel.y),this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray()),this._tmpMatrix.loadIdentity(),this._tmpMatrix.translateRelative(e.x,e.y*(t?-1:1)),this._tmpMatrix.scaleRelative(i,r*(t?-1:1)),this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x,-this._tmpBoundsOnModel.y),this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray())}setupLayoutBounds(t){var n=this._renderTextureCount<=1?ClippingMaskMaxCountOnDefault:ClippingMaskMaxCountOnMultiRenderTexture*this._renderTextureCount;if(t<=0||n<t){n<t&&CubismLogError("not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}",t-n,this._renderTextureCount,t);for(let t=0;t<this._clippingContextListForMask.getSize();t++){var e=this._clippingContextListForMask.at(t);e._layoutChannelIndex=0,e._layoutBounds.x=0,e._layoutBounds.y=0,e._layoutBounds.width=1,e._layoutBounds.height=1,e._bufferIndex=0}}else{var a=this._renderTextureCount<=1?9:8,i=t/this._renderTextureCount,o=t%this._renderTextureCount,l=(i=Math.ceil(i))/ColorChannelCount,u=i%ColorChannelCount,l=~~l;let s=0;for(let r=0;r<this._renderTextureCount;r++)for(let i=0;i<ColorChannelCount;i++){let e=l+(i<u?1:0);var p=u+(l<1?-1:0);if(i==p&&0<o&&(e-=r<o?0:1),0!=e)if(1==e){p=this._clippingContextListForMask.at(s++);p._layoutChannelIndex=i,p._layoutBounds.x=0,p._layoutBounds.y=0,p._layoutBounds.width=1,p._layoutBounds.height=1,p._bufferIndex=r}else if(2==e)for(let t=0;t<e;t++){var h=~~(t%2),_=this._clippingContextListForMask.at(s++);_._layoutChannelIndex=i,_._layoutBounds.x=.5*h,_._layoutBounds.y=0,_._layoutBounds.width=.5,_._layoutBounds.height=1,_._bufferIndex=r}else if(e<=4)for(let t=0;t<e;t++){var d=~~(t%2),C=~~(t/2),x=this._clippingContextListForMask.at(s++);x._layoutChannelIndex=i,x._layoutBounds.x=.5*d,x._layoutBounds.y=.5*C,x._layoutBounds.width=.5,x._layoutBounds.height=.5,x._bufferIndex=r}else if(e<=a)for(let t=0;t<e;t++){var c=~~(t%3),g=~~(t/3),m=this._clippingContextListForMask.at(s++);m._layoutChannelIndex=i,m._layoutBounds.x=c/3,m._layoutBounds.y=g/3,m._layoutBounds.width=1/3,m._layoutBounds.height=1/3,m._bufferIndex=r}else{CubismLogError("not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}",t-n,this._renderTextureCount,t);for(let t=0;t<e;t++){var M=this._clippingContextListForMask.at(s++);M._layoutChannelIndex=0,M._layoutBounds.x=0,M._layoutBounds.y=0,M._layoutBounds.width=1,M._layoutBounds.height=1,M._bufferIndex=0}}}}}calcClippedDrawTotalBounds(n,a){let o=Number.MAX_VALUE,l=Number.MAX_VALUE,u=Number.MIN_VALUE,p=Number.MIN_VALUE;var e=a._clippedDrawableIndexList.length;for(let t=0;t<e;t++){var h=a._clippedDrawableIndexList[t],_=n.getDrawableVertexCount(h),d=n.getDrawableVertices(h);let e=Number.MAX_VALUE,i=Number.MAX_VALUE,r=-Number.MAX_VALUE,s=-Number.MAX_VALUE;var C=_*Constant.vertexStep;for(let t=Constant.vertexOffset;t<C;t+=Constant.vertexStep){var x=d[t],c=d[t+1];x<e&&(e=x),x>r&&(r=x),c<i&&(i=c),c>s&&(s=c)}e!=Number.MAX_VALUE&&(e<o&&(o=e),i<l&&(l=i),r>u&&(u=r),s>p&&(p=s),o==Number.MAX_VALUE?(a._allClippedDrawRect.x=0,a._allClippedDrawRect.y=0,a._allClippedDrawRect.width=0,a._allClippedDrawRect.height=0,a._isUsing=!1):(a._isUsing=!0,h=u-o,_=p-l,a._allClippedDrawRect.x=o,a._allClippedDrawRect.y=l,a._allClippedDrawRect.width=h,a._allClippedDrawRect.height=_))}}getClippingContextListForDraw(){return this._clippingContextListForDraw}getClippingMaskBufferSize(){return this._clippingMaskBufferSize}getRenderTextureCount(){return this._renderTextureCount}getChannelFlagAsColor(t){return this._channelColors.at(t)}setClippingMaskBufferSize(t){this._clippingMaskBufferSize=t}}export{CubismClippingManager};